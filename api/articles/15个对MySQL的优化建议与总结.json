{"title":"15个对MySQL的优化建议与总结","slug":"15个对MySQL的优化建议与总结","date":"2018-10-14T09:14:20.000Z","updated":"2022-06-02T01:05:59.611Z","comments":true,"path":"api/articles/15个对MySQL的优化建议与总结.json","excerpt":"1、 为查询缓存优化查询像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，谨慎使用","covers":null,"content":"<p>1、 为查询缓存优化查询</p>\n<p>像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，谨慎使用</p>\n<p>2、EXPLAIN 我们的SELECT查询(可以查看执行的行数)</p>\n<p>可以让我们找到潜在的性能问题</p>\n<p>3、当只要一行数据时使用LIMIT 1</p>\n<p>MySQL数据库引擎会在查找到一条数据后停止搜索，而不是继续往后查询下一条符合条件的数据记录。</p>\n<p>4、为搜索字段建立索引</p>\n<p>在识别度高的列上建立正确的索引，以提升性能</p>\n<p>5、在Join表的时候使用相当类型的列，并将其索引</p>\n<p>关联表的关键字段，类型一致，字符集一致，才能提高性能，否则无法使用它们的索引</p>\n<p>6、千万不要 ORDER BY RAND ()</p>\n<p>执行RAND()函数（很耗CPU时间），会让你的数据库的性能呈指数级的下降</p>\n<p>7、 避免SELECT *</p>\n<p>从数据库里读出越多的数据，那么查询就会变得越慢。</p>\n<p>8、永远为每张表设置一个ID</p>\n<p>我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的 AUTO_INCREMENT标志。</p>\n<p>9、可以使用ENUM 而不要VARCHAR</p>\n<p>ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。</p>\n<p>10、尽可能的使用NOT NULL</p>\n<p>如果不是特殊情况，尽可能的不要使用NULL。在MYSQL中对于INT类型而言，EMPTY是0，而NULL是空值。而在Oracle中 NULL和EMPTY的字符串是一样的。NULL也需要占用存储空间，并且会使我们的程序判断时更加复杂。现实情况是很复杂的，依然会有些情况下，我们需要使用NULL值。</p>\n<p>11、固定长度的表会更快</p>\n<p>表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要我们包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。 固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。</p>\n<p>12、垂直分割</p>\n<p>“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。</p>\n<p>13、拆分打的DELETE或INSERT语句</p>\n<p>这两个操作是会锁表的</p>\n<p>14、越小的列会越快</p>\n<p>对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。越小的列消耗的io资源越少</p>\n<p>15、选择正确的存储引擎</p>\n<p>MyISAM是MYSQL5.5版本以前默认的存储引擎，基于传统的ISAM类型，支持B-Tree，全文检索，但是不是事务安全的，而且不支持外键。不具有原子性。支持锁表。</p>\n<p>总结</p>\n<p>InnoDB是事务型引擎，支持ACID事务(实现4种事务隔离机制)、回滚、崩溃恢复能力、行锁。以及提供与Oracle一致的不加锁的读取方式。InnoDB存储它的表和索引在一个表空间中，表空间可以包含多个文件。</p>\n<p>转载自<a href=\"https://www.toutiao.com/a6587214191122186766/\">https://www.toutiao.com/a6587214191122186766/</a></p>\n\n","more":"\n<p>2、EXPLAIN 我们的SELECT查询(可以查看执行的行数)</p>\n<p>可以让我们找到潜在的性能问题</p>\n<p>3、当只要一行数据时使用LIMIT 1</p>\n<p>MySQL数据库引擎会在查找到一条数据后停止搜索，而不是继续往后查询下一条符合条件的数据记录。</p>\n<p>4、为搜索字段建立索引</p>\n<p>在识别度高的列上建立正确的索引，以提升性能</p>\n<p>5、在Join表的时候使用相当类型的列，并将其索引</p>\n<p>关联表的关键字段，类型一致，字符集一致，才能提高性能，否则无法使用它们的索引</p>\n<p>6、千万不要 ORDER BY RAND ()</p>\n<p>执行RAND()函数（很耗CPU时间），会让你的数据库的性能呈指数级的下降</p>\n<p>7、 避免SELECT *</p>\n<p>从数据库里读出越多的数据，那么查询就会变得越慢。</p>\n<p>8、永远为每张表设置一个ID</p>\n<p>我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的 AUTO_INCREMENT标志。</p>\n<p>9、可以使用ENUM 而不要VARCHAR</p>\n<p>ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。</p>\n<p>10、尽可能的使用NOT NULL</p>\n<p>如果不是特殊情况，尽可能的不要使用NULL。在MYSQL中对于INT类型而言，EMPTY是0，而NULL是空值。而在Oracle中 NULL和EMPTY的字符串是一样的。NULL也需要占用存储空间，并且会使我们的程序判断时更加复杂。现实情况是很复杂的，依然会有些情况下，我们需要使用NULL值。</p>\n<p>11、固定长度的表会更快</p>\n<p>表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要我们包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。 固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。</p>\n<p>12、垂直分割</p>\n<p>“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。</p>\n<p>13、拆分打的DELETE或INSERT语句</p>\n<p>这两个操作是会锁表的</p>\n<p>14、越小的列会越快</p>\n<p>对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。越小的列消耗的io资源越少</p>\n<p>15、选择正确的存储引擎</p>\n<p>MyISAM是MYSQL5.5版本以前默认的存储引擎，基于传统的ISAM类型，支持B-Tree，全文检索，但是不是事务安全的，而且不支持外键。不具有原子性。支持锁表。</p>\n<p>总结</p>\n<p>InnoDB是事务型引擎，支持ACID事务(实现4种事务隔离机制)、回滚、崩溃恢复能力、行锁。以及提供与Oracle一致的不加锁的读取方式。InnoDB存储它的表和索引在一个表空间中，表空间可以包含多个文件。</p>\n<p>转载自<a href=\"https://www.toutiao.com/a6587214191122186766/\">https://www.toutiao.com/a6587214191122186766/</a></p>\n\n","categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"mysql","path":"api/tags/mysql.json"}]}