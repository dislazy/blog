{"title":"Java5-8新特性一览","slug":"Java5-8新特性一览","date":"2018-10-14T09:58:46.000Z","updated":"2022-06-02T01:05:59.613Z","comments":true,"path":"api/articles/Java5-8新特性一览.json","excerpt":"jdk5新特性1、自动装箱和拆箱","covers":null,"content":"<p>jdk5新特性</p>\n<p>1、自动装箱和拆箱</p>\n<p>2、枚举</p>\n<p>3、静态导入</p>\n<p>4、可变参数</p>\n<p>5、內省<br>   是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性那么，那我们可以通过getName，setName来得到其值或者设置新的值。通过getName&#x2F;setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter，setter方法，通过这些API可以使你不需要了解这个规则，这些API存放于包java.beans中。<br>   一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter&#x2F;setter方法，然后我们就可以通过反射机制来调用这些方法。</p>\n<p>6、泛型</p>\n<p>7、For-Each循环</p>\n<p>jdk6新特性</p>\n<p>1、Desktop类和SystemTray类</p>\n<p>   AWT新增加了两个雷：Desktop，SystemTray。</p>\n<p>   Desktop可以用来打开系统默认浏览器指定的URL，打开系统默认邮件客户端给指定的邮件账号发邮件，用默认应用程序打开或编辑文件（比如，用记事本打开txt文件），用系统默认的打印机打印文档SystemTray可以用来在系统托盘区创建一个托盘程序</p>\n<p>2、使用JAXB2来实现对象与XML之间的映射也就是对象与XML之间的映射（OXM），也可以通过XMLBeans和Castor等来实现同样的功能。</p>\n<p>3、StAX</p>\n<p>   StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；  SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。</p>\n<p>4、使用Compiler API使用JDK6的Compiler API去动态的编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码。</p>\n<p>5、轻量级Http Server API</p>\n<p>6、插入式注解处理API</p>\n<p>7、用Console开发控制台程序</p>\n<p>8、对脚本语言的支持如：ruby，groovy，javascript</p>\n<p>9、Common Annotations</p>\n<p>jdk7新特性</p>\n<p>1、switch中可以使用字符串</p>\n<p>2、泛型的自动判断</p>\n<p>3、自定义自动关闭类（实现AutoCloseable接口）</p>\n<p>4、新增一些取环境信息的工具方法（System中的方法）</p>\n<p>5、Boolean类型反转，空指针安全，参数与位运算</p>\n<p>6、两个char间的equals</p>\n<p>7、安全的加减乘除</p>\n<p>1、对Java集合（Collections）的增强支持</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list=[&quot;item&quot;]; //向List集合中添加元素</span><br><span class=\"line\">String item=list[0]; //从List集合中获取元素</span><br><span class=\"line\">Set&lt;String&gt; set=&#123;&quot;item&quot;&#125;; //向Set集合对象中添加元</span><br><span class=\"line\">Map&lt;String,Integer&gt; map=&#123;&quot;key&quot;:1&#125;; //向Map集合中添加对象</span><br><span class=\"line\">int value=map[&quot;key&quot;]; //从Map集合中获取对象</span><br><span class=\"line\">但是经过自己测试，按照上面的使用方法，并不能创建集合。</span><br></pre></td></tr></table></figure>\n<p>2、int支持二进制数据</p>\n<p>3、在try catch异常捕捉中，一个catch可以写多个异常类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection conn = null;</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class=\"line\">    conn = DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;);</span><br><span class=\"line\">&#125; catch(ClassNotFoundException|SQLException ex) &#123;</span><br><span class=\"line\">    ex.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">4、try catch中资源定义好之后try catch自动关闭</span><br><span class=\"line\">try (BufferedReader in  = new BufferedReader(new FileReader(&quot;in.txt&quot;));</span><br><span class=\"line\">     BufferedWriter out = new BufferedWriter(new FileWriter(&quot;out.txt&quot;))) &#123;</span><br><span class=\"line\">int charRead;</span><br><span class=\"line\">while ((charRead = in.read()) != -1) &#123;</span><br><span class=\"line\">        System.out.printf(&quot;%c &quot;, (char)charRead);</span><br><span class=\"line\">        out.write(charRead);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; catch (IOException ex) &#123;</span><br><span class=\"line\">    ex.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>jdk8新特性</p>\n<p>1、接口的默认方法</p>\n<p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Formula &#123;</span><br><span class=\"line\">    double calculate(int a);</span><br><span class=\"line\">    default double sqrt(int a) &#123;</span><br><span class=\"line\">return Math.sqrt(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    Formula formula = new Formula() &#123;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public double calculate(int a) &#123;</span><br><span class=\"line\">return sqrt(a * 100);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    System.out.println(formula.calculate(100));  // 100.0</span><br><span class=\"line\">    System.out.println(formula.sqrt(16));  // 4.0</span><br></pre></td></tr></table></figure>\n<p>文中的formula被实现为一个匿名类的实例，该代码非常<br>2、Lambda表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; names = Arrays.asList(&quot;tom&quot;,&quot;jace&quot;,&quot;mike&quot;);</span><br><span class=\"line\">Collections.sort(names, new Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public int compare(String o1, String o2) &#123;</span><br><span class=\"line\">return o2.compareTo(o1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>只需要给静态方法Collections.sort传入一个List对象以及一个比较器来指定顺序排列。通常做法都是创建一个匿名的比较器对象，然后将其传递给sort方法。</p>\n<p>在Java 8中提供了更简洁的语法，lambda表达式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class=\"line\">return b.compareTo(a);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>还可以更简洁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>\n<p>去掉大括号以及return关键字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(names, (a,b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>\n<p>Java编译器可以自动推导出参数类型，所以可以不用再写一次类型。</p>\n<p>3、函数式接口</p>\n<p>Lambda表达式是如何在java的类型系统中表示的呢？<br>每一个lambda表达式都对应着一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以也可以给自己的函数式接口添加默认方法。<br>我们可以将lambda表达式当做一个抽象方法的接口类型，确保自己的接口一定达到这个要求，你只需要给你的接口添加@FunctionalInterface注解，编译器如果发现标注了这个注解的接口有多于一个抽象方法的时候就会报错。也就是说@ FunctionalInterface注解标注的接口只能有一个抽象方法。</p>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface Converter&lt;F, T&gt; &#123;</span><br><span class=\"line\">T convert(F from);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class=\"line\">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class=\"line\">System.out.println(converted);</span><br></pre></td></tr></table></figure>\n<p>以上代码不需要@FunctionalInterface注解也是正确的。</p>\n<p>4、方法与构造函数引用</p>\n<p>上面的代码也可以通过静态方法引用来表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class=\"line\">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class=\"line\">System.out.println(converted);</span><br><span class=\"line\">Java8允许使用::关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</span><br><span class=\"line\">public class Person &#123;</span><br><span class=\"line\">    String firstName;</span><br><span class=\"line\">    String lastName;</span><br><span class=\"line\">    Person() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public Person(String firstName, String lastName) &#123;</span><br><span class=\"line\">this.firstName = firstName;</span><br><span class=\"line\">this.lastName = lastName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>指定一个用来创建Person对象的对象工厂接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface PersonFactory&lt;P extends Person&gt; &#123;</span><br><span class=\"line\">P create(String fisrtName, String lastName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建Person对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PersonFactory&lt;Person&gt; personFactory = Person::new;</span><br><span class=\"line\">Person person = personFactory.create(&quot;Peter&quot;,&quot;Parker”);</span><br></pre></td></tr></table></figure>\n<p>我们只需要使用Person::new 来获取Person类构造函数的引用，Java编译器就会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>\n<p>5、Lambda作用域</p>\n<p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p>\n<p>6、访问局部变量</p>\n<p>我们可以直接在lambda表达式中访问外层的局部变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final int num = 1;</span><br><span class=\"line\">Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);</span><br><span class=\"line\">stringConverter.convert(2);</span><br></pre></td></tr></table></figure>\n<p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确。</p>\n<p>7、访问对象字段与静态变量<br>和本地不良不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int outerStaticNum;</span><br><span class=\"line\">int outerNum;</span><br><span class=\"line\">public void testScopes() &#123;</span><br><span class=\"line\">    Converter stringConverter1 = (from) -&gt; &#123;</span><br><span class=\"line\">        outerNum = 23;</span><br><span class=\"line\">        return String.valueOf(from);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    Converter stringConverter2 = (from) -&gt; &#123;</span><br><span class=\"line\">        outerStaticNum = 72;</span><br><span class=\"line\">        return String.valueOf(from);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>8、访问接口的默认方法</p>\n<p>9、Date API</p>\n<p>10、Annotation注解</p>\n\n","more":"\n<p>2、枚举</p>\n<p>3、静态导入</p>\n<p>4、可变参数</p>\n<p>5、內省<br>   是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性那么，那我们可以通过getName，setName来得到其值或者设置新的值。通过getName&#x2F;setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter，setter方法，通过这些API可以使你不需要了解这个规则，这些API存放于包java.beans中。<br>   一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter&#x2F;setter方法，然后我们就可以通过反射机制来调用这些方法。</p>\n<p>6、泛型</p>\n<p>7、For-Each循环</p>\n<p>jdk6新特性</p>\n<p>1、Desktop类和SystemTray类</p>\n<p>   AWT新增加了两个雷：Desktop，SystemTray。</p>\n<p>   Desktop可以用来打开系统默认浏览器指定的URL，打开系统默认邮件客户端给指定的邮件账号发邮件，用默认应用程序打开或编辑文件（比如，用记事本打开txt文件），用系统默认的打印机打印文档SystemTray可以用来在系统托盘区创建一个托盘程序</p>\n<p>2、使用JAXB2来实现对象与XML之间的映射也就是对象与XML之间的映射（OXM），也可以通过XMLBeans和Castor等来实现同样的功能。</p>\n<p>3、StAX</p>\n<p>   StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；  SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。</p>\n<p>4、使用Compiler API使用JDK6的Compiler API去动态的编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码。</p>\n<p>5、轻量级Http Server API</p>\n<p>6、插入式注解处理API</p>\n<p>7、用Console开发控制台程序</p>\n<p>8、对脚本语言的支持如：ruby，groovy，javascript</p>\n<p>9、Common Annotations</p>\n<p>jdk7新特性</p>\n<p>1、switch中可以使用字符串</p>\n<p>2、泛型的自动判断</p>\n<p>3、自定义自动关闭类（实现AutoCloseable接口）</p>\n<p>4、新增一些取环境信息的工具方法（System中的方法）</p>\n<p>5、Boolean类型反转，空指针安全，参数与位运算</p>\n<p>6、两个char间的equals</p>\n<p>7、安全的加减乘除</p>\n<p>1、对Java集合（Collections）的增强支持</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list=[&quot;item&quot;]; //向List集合中添加元素</span><br><span class=\"line\">String item=list[0]; //从List集合中获取元素</span><br><span class=\"line\">Set&lt;String&gt; set=&#123;&quot;item&quot;&#125;; //向Set集合对象中添加元</span><br><span class=\"line\">Map&lt;String,Integer&gt; map=&#123;&quot;key&quot;:1&#125;; //向Map集合中添加对象</span><br><span class=\"line\">int value=map[&quot;key&quot;]; //从Map集合中获取对象</span><br><span class=\"line\">但是经过自己测试，按照上面的使用方法，并不能创建集合。</span><br></pre></td></tr></table></figure>\n<p>2、int支持二进制数据</p>\n<p>3、在try catch异常捕捉中，一个catch可以写多个异常类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection conn = null;</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class=\"line\">    conn = DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;);</span><br><span class=\"line\">&#125; catch(ClassNotFoundException|SQLException ex) &#123;</span><br><span class=\"line\">    ex.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">4、try catch中资源定义好之后try catch自动关闭</span><br><span class=\"line\">try (BufferedReader in  = new BufferedReader(new FileReader(&quot;in.txt&quot;));</span><br><span class=\"line\">     BufferedWriter out = new BufferedWriter(new FileWriter(&quot;out.txt&quot;))) &#123;</span><br><span class=\"line\">int charRead;</span><br><span class=\"line\">while ((charRead = in.read()) != -1) &#123;</span><br><span class=\"line\">        System.out.printf(&quot;%c &quot;, (char)charRead);</span><br><span class=\"line\">        out.write(charRead);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; catch (IOException ex) &#123;</span><br><span class=\"line\">    ex.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>jdk8新特性</p>\n<p>1、接口的默认方法</p>\n<p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特征又叫做扩展方法，示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Formula &#123;</span><br><span class=\"line\">    double calculate(int a);</span><br><span class=\"line\">    default double sqrt(int a) &#123;</span><br><span class=\"line\">return Math.sqrt(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    Formula formula = new Formula() &#123;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public double calculate(int a) &#123;</span><br><span class=\"line\">return sqrt(a * 100);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    System.out.println(formula.calculate(100));  // 100.0</span><br><span class=\"line\">    System.out.println(formula.sqrt(16));  // 4.0</span><br></pre></td></tr></table></figure>\n<p>文中的formula被实现为一个匿名类的实例，该代码非常<br>2、Lambda表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; names = Arrays.asList(&quot;tom&quot;,&quot;jace&quot;,&quot;mike&quot;);</span><br><span class=\"line\">Collections.sort(names, new Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public int compare(String o1, String o2) &#123;</span><br><span class=\"line\">return o2.compareTo(o1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>只需要给静态方法Collections.sort传入一个List对象以及一个比较器来指定顺序排列。通常做法都是创建一个匿名的比较器对象，然后将其传递给sort方法。</p>\n<p>在Java 8中提供了更简洁的语法，lambda表达式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class=\"line\">return b.compareTo(a);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>还可以更简洁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>\n<p>去掉大括号以及return关键字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(names, (a,b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>\n<p>Java编译器可以自动推导出参数类型，所以可以不用再写一次类型。</p>\n<p>3、函数式接口</p>\n<p>Lambda表达式是如何在java的类型系统中表示的呢？<br>每一个lambda表达式都对应着一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以也可以给自己的函数式接口添加默认方法。<br>我们可以将lambda表达式当做一个抽象方法的接口类型，确保自己的接口一定达到这个要求，你只需要给你的接口添加@FunctionalInterface注解，编译器如果发现标注了这个注解的接口有多于一个抽象方法的时候就会报错。也就是说@ FunctionalInterface注解标注的接口只能有一个抽象方法。</p>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface Converter&lt;F, T&gt; &#123;</span><br><span class=\"line\">T convert(F from);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class=\"line\">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class=\"line\">System.out.println(converted);</span><br></pre></td></tr></table></figure>\n<p>以上代码不需要@FunctionalInterface注解也是正确的。</p>\n<p>4、方法与构造函数引用</p>\n<p>上面的代码也可以通过静态方法引用来表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class=\"line\">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class=\"line\">System.out.println(converted);</span><br><span class=\"line\">Java8允许使用::关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</span><br><span class=\"line\">public class Person &#123;</span><br><span class=\"line\">    String firstName;</span><br><span class=\"line\">    String lastName;</span><br><span class=\"line\">    Person() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public Person(String firstName, String lastName) &#123;</span><br><span class=\"line\">this.firstName = firstName;</span><br><span class=\"line\">this.lastName = lastName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>指定一个用来创建Person对象的对象工厂接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface PersonFactory&lt;P extends Person&gt; &#123;</span><br><span class=\"line\">P create(String fisrtName, String lastName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建Person对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PersonFactory&lt;Person&gt; personFactory = Person::new;</span><br><span class=\"line\">Person person = personFactory.create(&quot;Peter&quot;,&quot;Parker”);</span><br></pre></td></tr></table></figure>\n<p>我们只需要使用Person::new 来获取Person类构造函数的引用，Java编译器就会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>\n<p>5、Lambda作用域</p>\n<p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p>\n<p>6、访问局部变量</p>\n<p>我们可以直接在lambda表达式中访问外层的局部变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final int num = 1;</span><br><span class=\"line\">Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);</span><br><span class=\"line\">stringConverter.convert(2);</span><br></pre></td></tr></table></figure>\n<p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确。</p>\n<p>7、访问对象字段与静态变量<br>和本地不良不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int outerStaticNum;</span><br><span class=\"line\">int outerNum;</span><br><span class=\"line\">public void testScopes() &#123;</span><br><span class=\"line\">    Converter stringConverter1 = (from) -&gt; &#123;</span><br><span class=\"line\">        outerNum = 23;</span><br><span class=\"line\">        return String.valueOf(from);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    Converter stringConverter2 = (from) -&gt; &#123;</span><br><span class=\"line\">        outerStaticNum = 72;</span><br><span class=\"line\">        return String.valueOf(from);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>8、访问接口的默认方法</p>\n<p>9、Date API</p>\n<p>10、Annotation注解</p>\n\n","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"}]}