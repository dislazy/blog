{"title":"nginx负载均衡策略","slug":"nginx负载均衡策略","date":"2018-10-12T02:02:04.000Z","updated":"2022-06-02T01:05:59.616Z","comments":true,"path":"api/articles/nginx负载均衡策略.json","excerpt":"nginx负载均衡策略相对来说比较方便配置。策略有以下几种：","covers":null,"content":"<p>nginx负载均衡策略相对来说比较方便配置。</p>\n<p>策略有以下几种：</p>\n<p>1)、轮询（默认） </p>\n<p>　　每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream  test   </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    server   10.0.1.31:8080;</span><br><span class=\"line\">    server   10.0.1.32:8080;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    listen  80;</span><br><span class=\"line\">    server_name  www.xxxx.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass        http://test;</span><br><span class=\"line\">        proxy_set_header   Host             $host;</span><br><span class=\"line\">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class=\"line\">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2)、weight </p>\n<p>　　指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream test </span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    server 10.0.1.31:8080 down; </span><br><span class=\"line\">    server 10.0.1.32:8080 weight=2; </span><br><span class=\"line\">    server 10.0.1.33:8080; </span><br><span class=\"line\">    server 10.0.1.34:8080 backup; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    listen  80;</span><br><span class=\"line\">    server_name  www.xxxx.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass        http://test;</span><br><span class=\"line\">        proxy_set_header   Host             $host;</span><br><span class=\"line\">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class=\"line\">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">upstream 每个设备的状态:</span><br><span class=\"line\">down 表示单前的server暂时不参与负载 </span><br><span class=\"line\">weight  默认为1.weight越大，负载的权重就越大。 </span><br><span class=\"line\">max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 </span><br><span class=\"line\">fail_timeout:max_fails 次失败后，暂停的时间。 </span><br><span class=\"line\">backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻</span><br></pre></td></tr></table></figure>\n<p>3)、ip_hash </p>\n<p>　　每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream test &#123;</span><br><span class=\"line\">    server 127.0.0.1:8080 ;</span><br><span class=\"line\">    server 127.0.0.1:9090 ;</span><br><span class=\"line\">    ip_hash;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    listen  80;</span><br><span class=\"line\">    server_name  www.xxxx.com;</span><br><span class=\"line\"> </span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass        http://test;</span><br><span class=\"line\">        proxy_set_header   Host             $host;</span><br><span class=\"line\">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class=\"line\">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4)、第三方插件 </p>\n<p>关于第三方插件，可以自行了解一下， 本文不做赘述</p>\n<h3 id=\"负载均衡导致的问题\"><a href=\"#负载均衡导致的问题\" class=\"headerlink\" title=\"负载均衡导致的问题\"></a>负载均衡导致的问题</h3><p>在实际应用中，负载均衡肯定不会只用于静态页面，更多的是页面的交互，这样一来session会话的保持变成了负载均衡的问题所在。</p>\n<p>session的保持主要可以使用三种方式</p>\n<p>1、会话保持</p>\n<p>对于Nginx可以选用Session保持的方法实行负载均衡，nginx的upstream目前支持5种方式的分配方式，其中有两种比较通用的Session解决方法，ip_hash和url_hash。注意：后者不是官方模块，需要额外安装。</p>\n<p>ip_hash</p>\n<p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，达到了Session保持的方法。此种方法实现在上面有说明。</p>\n<p>它的缺点是</p>\n<p>负载未实现真正意义的均衡：由于使用了Session保持，很显然就无法保证负载绝对的均衡。</p>\n<p>会话丢失可能性较大：如果后端有服务器宕机，那么这台服务器的Session丢失，被分配到这台服务请求的用户还是需要重新登录。</p>\n<p>2、会话复制</p>\n<p>会话复制在Tomcat上得到了支持，它是基于IP组播（multicast）来完成Session的复制，Tomcat的会话复制分为两种：</p>\n<p>全局会话复制：利用Delta Manager复制会话中的变更信息到集群中的所有其他节点。</p>\n<p>非全局复制：使用Backup Manager进行复制，它会把Session复制给一个指定的备份节点。</p>\n<p>可以参考Tomcat官方文档，主要是因为会话复制不适合大的集群。不推荐生产服务器使用此种方式。</p>\n<p>3、会话共享</p>\n<p>共享就意味着借用第三方缓存来对seesion进行存储，后端服务器可根据存储来判断会话的正确性。</p>\n<p>缓存的方式较多，比较常用的方法是redis缓存，redis是key-value的内存性数据库，吞吐量极高，在一定的内存下，除非并发数极高，否则很难达到redis的吞吐极限。</p>\n<p>使用redis作为session缓存，直接将会话信息存储到redis中，服务端以高效率读取redis中session，实现了负载均衡情况下seesion的会话保持。它的性能决定了它的瓶颈较高，<br>一般情况下足够使用。</p>\n\n","more":"\n<p>1)、轮询（默认） </p>\n<p>　　每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream  test   </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    server   10.0.1.31:8080;</span><br><span class=\"line\">    server   10.0.1.32:8080;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    listen  80;</span><br><span class=\"line\">    server_name  www.xxxx.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass        http://test;</span><br><span class=\"line\">        proxy_set_header   Host             $host;</span><br><span class=\"line\">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class=\"line\">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2)、weight </p>\n<p>　　指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream test </span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    server 10.0.1.31:8080 down; </span><br><span class=\"line\">    server 10.0.1.32:8080 weight=2; </span><br><span class=\"line\">    server 10.0.1.33:8080; </span><br><span class=\"line\">    server 10.0.1.34:8080 backup; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    listen  80;</span><br><span class=\"line\">    server_name  www.xxxx.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass        http://test;</span><br><span class=\"line\">        proxy_set_header   Host             $host;</span><br><span class=\"line\">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class=\"line\">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">upstream 每个设备的状态:</span><br><span class=\"line\">down 表示单前的server暂时不参与负载 </span><br><span class=\"line\">weight  默认为1.weight越大，负载的权重就越大。 </span><br><span class=\"line\">max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 </span><br><span class=\"line\">fail_timeout:max_fails 次失败后，暂停的时间。 </span><br><span class=\"line\">backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻</span><br></pre></td></tr></table></figure>\n<p>3)、ip_hash </p>\n<p>　　每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream test &#123;</span><br><span class=\"line\">    server 127.0.0.1:8080 ;</span><br><span class=\"line\">    server 127.0.0.1:9090 ;</span><br><span class=\"line\">    ip_hash;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    listen  80;</span><br><span class=\"line\">    server_name  www.xxxx.com;</span><br><span class=\"line\"> </span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass        http://test;</span><br><span class=\"line\">        proxy_set_header   Host             $host;</span><br><span class=\"line\">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class=\"line\">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4)、第三方插件 </p>\n<p>关于第三方插件，可以自行了解一下， 本文不做赘述</p>\n<h3 id=\"负载均衡导致的问题\"><a href=\"#负载均衡导致的问题\" class=\"headerlink\" title=\"负载均衡导致的问题\"></a>负载均衡导致的问题</h3><p>在实际应用中，负载均衡肯定不会只用于静态页面，更多的是页面的交互，这样一来session会话的保持变成了负载均衡的问题所在。</p>\n<p>session的保持主要可以使用三种方式</p>\n<p>1、会话保持</p>\n<p>对于Nginx可以选用Session保持的方法实行负载均衡，nginx的upstream目前支持5种方式的分配方式，其中有两种比较通用的Session解决方法，ip_hash和url_hash。注意：后者不是官方模块，需要额外安装。</p>\n<p>ip_hash</p>\n<p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，达到了Session保持的方法。此种方法实现在上面有说明。</p>\n<p>它的缺点是</p>\n<p>负载未实现真正意义的均衡：由于使用了Session保持，很显然就无法保证负载绝对的均衡。</p>\n<p>会话丢失可能性较大：如果后端有服务器宕机，那么这台服务器的Session丢失，被分配到这台服务请求的用户还是需要重新登录。</p>\n<p>2、会话复制</p>\n<p>会话复制在Tomcat上得到了支持，它是基于IP组播（multicast）来完成Session的复制，Tomcat的会话复制分为两种：</p>\n<p>全局会话复制：利用Delta Manager复制会话中的变更信息到集群中的所有其他节点。</p>\n<p>非全局复制：使用Backup Manager进行复制，它会把Session复制给一个指定的备份节点。</p>\n<p>可以参考Tomcat官方文档，主要是因为会话复制不适合大的集群。不推荐生产服务器使用此种方式。</p>\n<p>3、会话共享</p>\n<p>共享就意味着借用第三方缓存来对seesion进行存储，后端服务器可根据存储来判断会话的正确性。</p>\n<p>缓存的方式较多，比较常用的方法是redis缓存，redis是key-value的内存性数据库，吞吐量极高，在一定的内存下，除非并发数极高，否则很难达到redis的吞吐极限。</p>\n<p>使用redis作为session缓存，直接将会话信息存储到redis中，服务端以高效率读取redis中session，实现了负载均衡情况下seesion的会话保持。它的性能决定了它的瓶颈较高，<br>一般情况下足够使用。</p>\n\n","categories":[{"name":"Linux","path":"api/categories/Linux.json"}],"tags":[{"name":"nginx","path":"api/tags/nginx.json"}]}