{"title":"mysql的table复制","slug":"mysql的table复制","date":"2022-01-09T06:58:14.000Z","updated":"2022-06-02T01:05:59.616Z","comments":true,"path":"api/articles/mysql的table复制.json","excerpt":"起因前段时间在鼓捣数据表的数据上线，主要流程是将线下的数据同步到线上去，线上的部分需要需要和线下保持一直，并且每一次操作都需要自动化将表进行备份， 这个过程主要是靠自己进行代码同步，因为规则比较自定义，所以没有使用一些现有的数据同步。主要流程如下：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>- #备份NX的SCHEMA中的表并查询特定数据进行备用<br>NX-SCHEMA: 备份NX-TABLE ==&gt; NX-TABLE_COPY ==&gt; SELECT * FROM NX-TABLE_COPY WHERE ID =xx<br><br>- #备份JAPAB的SCHEMA中的表并且将上一步的数据写入到备份表中<br>JAPAN-SCHEMA: BEFEN JAPAN-TABLE ==&gt; JAPAN-TABLE_COPY ==&gt; INSERT INTO JAPAN-TABLE_COPY VALUE (xxx)<br><br>- #将JAPAN的SCHEMA中的原表和备份表进行重命名，将备份表的表名变成源表名，完成数据上线<br>JAPAN-SCHEMA: JAPAN-TABLE ==&gt; RENAME JAPAN-TABL XXX ==&gt; RENAME JAPAN-TABLE_COPY TO JAPAN-TABLE<br><br>在这个过程中，我们最主要的一步是在同一个schema下进行将原表进行备份，创建一个对应的不同表，后续所有的操作都改这个表中操作，在这个过程中也是出现了一些问题，后续经过实践后解决了相关问题，特此记录。经过我们在备份源Schema中的table时，直接采取了简单粗暴的SQL语句，如下：create table table_name_copy as select * from table_name,该SQL实现了创建table_name_copy并且将table_name中的数据也插入到对应的新表中，<br>看似满足了我们的需求：朴素的备份源表，不进行任何操作。然而，简单的事情总是不会那么简单，在我们进行数据比对时，发现数据没啥问题，但是在校验表的DDL时，发现麻烦稍微有点大，此次备份基本没用，因为此时我们的表的主键、索引等等都丢失了，然后我们再查询相关的文档，发现弊端还挺多。然后在此上进行了改进，先根据ddl创建表的结构，然后再讲数据导入进来，这样就避免了锁、和索引等问题。SQL如下：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>第一步：创建表结构<br><br>方法一： 按照老表的结构创建新表<br>create table new_table like old_table;<br>方法二： 此种方法是先获取ddl，然后再修改表名再次执行DDL，进行表结构创建<br>SHOW CREATE TABLE old_table;<br><br>第二步：同步原表数据<br>INSERT INTO new_table SELECT * FROM old_table;<br><br>备份表的结构和数据都还是比较简单，但是这个只适用于少量数据的备份，大量数据的备份暂时还没有进行实践，我们大量的数据备份一般使用CSV或者ETL进行同步。","covers":null,"content":"<div class=\"story post-story\"><h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>前段时间在鼓捣数据表的数据上线，主要流程是将线下的数据同步到线上去，线上的部分需要需要和线下保持一直，并且每一次操作都需要自动化将表进行备份， 这个过程主要是靠自己进行代码同步，因为规则比较自定义，所以没有使用一些现有的数据同步。</p>\n<p>主要流程如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- #备份NX的SCHEMA中的表并查询特定数据进行备用</span><br><span class=\"line\">NX-SCHEMA: 备份NX-TABLE ==&gt; NX-TABLE_COPY ==&gt; SELECT * FROM NX-TABLE_COPY WHERE ID =xx</span><br><span class=\"line\"></span><br><span class=\"line\">- #备份JAPAB的SCHEMA中的表并且将上一步的数据写入到备份表中</span><br><span class=\"line\">JAPAN-SCHEMA: BEFEN JAPAN-TABLE ==&gt; JAPAN-TABLE_COPY ==&gt; INSERT INTO JAPAN-TABLE_COPY VALUE (xxx)</span><br><span class=\"line\"></span><br><span class=\"line\">- #将JAPAN的SCHEMA中的原表和备份表进行重命名，将备份表的表名变成源表名，完成数据上线</span><br><span class=\"line\">JAPAN-SCHEMA: JAPAN-TABLE ==&gt; RENAME JAPAN-TABL XXX ==&gt; RENAME JAPAN-TABLE_COPY TO JAPAN-TABLE</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这个过程中，我们最主要的一步是在同一个schema下进行将原表进行备份，创建一个对应的不同表，后续所有的操作都改这个表中操作，在这个过程中也是出现了一些问题，后续经过实践后解决了相关问题，特此记录。</p>\n</div><div class=\"story post-story\"><h2 id=\"经过\"><a href=\"#经过\" class=\"headerlink\" title=\"经过\"></a>经过</h2><p>我们在备份源Schema中的table时，直接采取了简单粗暴的SQL语句，如下：<code>create table table_name_copy as select * from table_name</code>,该SQL实现了创建<code>table_name_copy</code>并且将<code>table_name</code>中的数据也插入到对应的新表中，<br>看似满足了我们的需求：朴素的备份源表，不进行任何操作。</p>\n<p>然而，简单的事情总是不会那么简单，在我们进行数据比对时，发现数据没啥问题，但是在校验表的DDL时，发现麻烦稍微有点大，此次备份基本没用，因为此时我们的表的主键、索引等等都丢失了，然后我们再查询相关的文档，发现弊端还挺多。</p>\n<p>然后在此上进行了改进，先根据ddl创建表的结构，然后再讲数据导入进来，这样就避免了锁、和索引等问题。SQL如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一步：创建表结构</span><br><span class=\"line\"></span><br><span class=\"line\">方法一： 按照老表的结构创建新表</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> new_table <span class=\"keyword\">like</span> old_table;</span><br><span class=\"line\">方法二： 此种方法是先获取ddl，然后再修改表名再次执行DDL，进行表结构创建</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> old_table;</span><br><span class=\"line\"></span><br><span class=\"line\">第二步：同步原表数据</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> new_table <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> old_table;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>备份表的结构和数据都还是比较简单，但是这个只适用于少量数据的备份，大量数据的备份暂时还没有进行实践，我们大量的数据备份一般使用CSV或者ETL进行同步。</p>\n</div><div class=\"story post-story\"><h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>在同步表结构的过程中出现了一些小的插曲，但是还是圆满的解决了问题，在严格检查的前提下发现了问题，在没有发生故障的情况下及时止损，以后的相关内容也是需要多查文档，锁看看原理，严格进行数据和DDL校验，发现问题速度处理，及时止损。</p>\n\n</div>","more":"<div class=\"story post-story\"><h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>在同步表结构的过程中出现了一些小的插曲，但是还是圆满的解决了问题，在严格检查的前提下发现了问题，在没有发生故障的情况下及时止损，以后的相关内容也是需要多查文档，锁看看原理，严格进行数据和DDL校验，发现问题速度处理，及时止损。</p>\n\n</div>","categories":[{"name":"mysql","path":"api/categories/mysql.json"}],"tags":[{"name":"mysql","path":"api/tags/mysql.json"}]}