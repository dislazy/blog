{"title":"关于Spring中@transactional的一些理解","slug":"关于Spring中@transactional的一些理解","date":"2020-01-19T08:59:56.000Z","updated":"2022-06-02T01:05:59.617Z","comments":true,"path":"api/articles/关于Spring中@transactional的一些理解.json","excerpt":"在我们的数据库开发的过程中，很多关键性的操作都需要使用到事务，保证数据的一致性和安全性。Spring为事务管理提供了非常丰富的支持，主要分为编码式(通过编码方式实现事务)、声明式(基于AOP，将具体业务逻辑与事务处理逻辑进行解耦)。编码式的事务使用起来较为繁琐，会对代码造成侵入，破坏整体的协调性。声明式则不然，在日常使用中声明式的使用相对比较频繁，它可以在xml中做相关事务规则配置，还有一种则是@Transactional 注解的方式。今天就@Transactional 的注解使用来简单的谈一谈我的理解。@Transactional 注解管理事务的实现步骤使用@Transactional 注解管理事务的实现步骤分为两步。第一步，在 xml 配置文件中添加事务配置信息。除了用配置文件的方式，@EnableTransactionManagement 注解也可以启用事务管理功能。这里以简单的 DataSourceTransactionManager 为例。一、 在 xml 配置中的事务配置信息1<br>2<br>3<br>4<br>5<br>&lt;tx:annotation-driven /&gt;<br>&lt;bean id=&quot;transactionManager&quot;<br>class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;<br>&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;<br>&lt;/bean&gt;<br>第二步，将@Transactional 注解添加到合适的方法上，并设置合适的属性信息。@Transactional 注解的属性信息如表 1 展示。表 1. @Transactional 注解的属性信息属性名说明name当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。propagation事务的传播行为，默认值为 REQUIRED，具体见：propagation解释isolation事务的隔离度，默认值采用 DEFAULT，具体见：isolation解释timeout事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。read-only指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。rollback-for用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。no-rollback- for抛出 no-rollback-for 指定的异常类型，不回滚事务。propagation解释属性表现REQUIRED支持当前事务，若没有就新建-默认模式SUPPORTS支持当前事务，若没有就以非事务方式进行MANDATORY支持当前事务，若没有就抛异常REQUIRES_NEW新建事务，若存在当前事务，则挂起当前事务NOT_SUPPORTED以非事务方式执行操作，若存在当前事务，则挂起当前事务NEVER以非事务方式执行操作，若存在当前事务则抛异常NESTED支持当前事务，若当前事务存在，则嵌套一个事务，如果不存在，则新建isolation解释属性表现DEFAULT使用数据库默认的隔离级别READ_UNCOMMITTED允许读取未提交的更改。可能导致脏读、幻读、不可重复读READ_COMMITTED允许从已经提交的并发事务读取，可防止脏读，但幻读、不可重复仍可能发生REPEATABLE_READ对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。SERIALIZABLE完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。除此以外，@Transactional 注解也可以添加到类级别上。当把@Transactional 注解放在类级别时，表示所有该类的公共方法都配置相同的事务属性信息。见清单 2，EmployeeService 的所有方法都支持事务并且是只读。当类级别配置了@Transactional，方法级别也配置了@Transactional，应用程序会以方法级别的事务属性信息来管理事务，换言之，方法级别的事务属性信息会覆盖类级别的相关配置信息。二、 @Transactional 注解的类级别支持1<br>2<br>3<br>@Transactional(propagation= Propagation.SUPPORTS,readOnly=true)<br>@Service(value =&quot;employeeService&quot;)<br>public class EmployeeService<br>到此，发现使用@Transactional 注解管理事务的实现步骤其实很简单。但是如果对 Spring 中的 @Transactional 注解的事务管理理解的不够透彻，就很容易出现错误，比如事务应该回滚（rollback）而没有回滚事务的问题。下面看一看注册的事务实现的机制和常见的问题及解决方案。","covers":["https://imagecdn.bosong.online/blog/image001.jpg","https://imagecdn.bosong.online/blog/image002.jpg"],"content":"<p>在我们的数据库开发的过程中，很多关键性的操作都需要使用到事务，保证数据的一致性和安全性。Spring为事务管理提供了非常丰富的支持，主要分为编码式(通过编码方式实现事务)、声明式(基于<code>AOP</code>，将具体业务逻辑与事务处理逻辑进行解耦)。编码式的事务使用起来较为繁琐，会对代码造成侵入，破坏整体的协调性。声明式则不然，在日常使用中声明式的使用相对比较频繁，它可以在<code>xml</code>中做相关事务规则配置，还有一种则是<code>@Transactional </code>注解的方式。今天就<code>@Transactiona</code>l 的注解使用来简单的谈一谈我的理解。</p>\n<div class=\"story post-story\"><h2 id=\"Transactional-注解管理事务的实现步骤\"><a href=\"#Transactional-注解管理事务的实现步骤\" class=\"headerlink\" title=\"@Transactional 注解管理事务的实现步骤\"></a>@Transactional 注解管理事务的实现步骤</h2><p>使用@Transactional 注解管理事务的实现步骤分为两步。</p>\n<p>第一步，在 <code>xml</code> 配置文件中添加事务配置信息。除了用配置文件的方式，<code>@EnableTransactionManagement </code>注解也可以启用事务管理功能。这里以简单的 <code>DataSourceTransactionManager </code>为例。</p>\n<h4 id=\"一、-在-xml-配置中的事务配置信息\"><a href=\"#一、-在-xml-配置中的事务配置信息\" class=\"headerlink\" title=\"一、 在 xml 配置中的事务配置信息\"></a>一、 在 <code>xml</code> 配置中的事务配置信息</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;transactionManager&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>第二步，将<code>@Transactional</code> 注解添加到合适的方法上，并设置合适的属性信息。<code>@Transactional</code> 注解的属性信息如表 1 展示。</p>\n<h5 id=\"表-1-Transactional-注解的属性信息\"><a href=\"#表-1-Transactional-注解的属性信息\" class=\"headerlink\" title=\"表 1. @Transactional 注解的属性信息\"></a>表 1. @Transactional 注解的属性信息</h5><table>\n<thead>\n<tr>\n<th align=\"left\">属性名</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>name</code></td>\n<td align=\"left\">当在配置文件中有多个 <code>TransactionManager</code> , 可以用该属性指定选择哪个事务管理器。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>propagation</code></td>\n<td align=\"left\">事务的传播行为，默认值为 REQUIRED，具体见：propagation解释</td>\n</tr>\n<tr>\n<td align=\"left\"><code>isolation</code></td>\n<td align=\"left\">事务的隔离度，默认值采用 DEFAULT，具体见：isolation解释</td>\n</tr>\n<tr>\n<td align=\"left\"><code>timeout</code></td>\n<td align=\"left\">事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>read-only</code></td>\n<td align=\"left\">指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>rollback-for</code></td>\n<td align=\"left\">用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>no-rollback- for</code></td>\n<td align=\"left\">抛出 no-rollback-for 指定的异常类型，不回滚事务。</td>\n</tr>\n</tbody></table>\n<h6 id=\"propagation解释\"><a href=\"#propagation解释\" class=\"headerlink\" title=\"propagation解释\"></a><code>propagation</code>解释</h6><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>表现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>REQUIRED</code></td>\n<td>支持当前事务，若没有就新建-默认模式</td>\n</tr>\n<tr>\n<td><code>SUPPORTS</code></td>\n<td>支持当前事务，若没有就以非事务方式进行</td>\n</tr>\n<tr>\n<td><code>MANDATORY</code></td>\n<td>支持当前事务，若没有就抛异常</td>\n</tr>\n<tr>\n<td><code>REQUIRES_NEW</code></td>\n<td>新建事务，若存在当前事务，则挂起当前事务</td>\n</tr>\n<tr>\n<td><code>NOT_SUPPORTED</code></td>\n<td>以非事务方式执行操作，若存在当前事务，则挂起当前事务</td>\n</tr>\n<tr>\n<td><code>NEVER</code></td>\n<td>以非事务方式执行操作，若存在当前事务则抛异常</td>\n</tr>\n<tr>\n<td><code>NESTED</code></td>\n<td>支持当前事务，若当前事务存在，则嵌套一个事务，如果不存在，则新建</td>\n</tr>\n</tbody></table>\n<h6 id=\"isolation解释\"><a href=\"#isolation解释\" class=\"headerlink\" title=\"isolation解释\"></a><code>isolation</code>解释</h6><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>表现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DEFAULT</code></td>\n<td>使用数据库默认的隔离级别</td>\n</tr>\n<tr>\n<td><code>READ_UNCOMMITTED</code></td>\n<td>允许读取未提交的更改。可能导致脏读、幻读、不可重复读</td>\n</tr>\n<tr>\n<td><code>READ_COMMITTED</code></td>\n<td>允许从已经提交的并发事务读取，可防止脏读，但幻读、不可重复仍可能发生</td>\n</tr>\n<tr>\n<td><code>REPEATABLE_READ</code></td>\n<td>对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。</td>\n</tr>\n<tr>\n<td><code>SERIALIZABLE</code></td>\n<td>完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。</td>\n</tr>\n</tbody></table>\n<p>除此以外，<code>@Transactional</code> 注解也可以添加到类级别上。</p>\n<p>当把<code>@Transactional </code>注解放在类级别时，表示所有该类的公共方法都配置相同的事务属性信息。见清单 2，<code>EmployeeService</code> 的所有方法都支持事务并且是只读。当类级别配置了<code>@Transactional</code>，方法级别也配置了<code>@Transactional</code>，应用程序会以方法级别的事务属性信息来管理事务，换言之，方法级别的事务属性信息会覆盖类级别的相关配置信息。</p>\n<h4 id=\"二、-Transactional-注解的类级别支持\"><a href=\"#二、-Transactional-注解的类级别支持\" class=\"headerlink\" title=\"二、 @Transactional 注解的类级别支持\"></a>二、 @Transactional 注解的类级别支持</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(propagation= Propagation.SUPPORTS,readOnly=true)</span></span><br><span class=\"line\"><span class=\"meta\">@Service(value =&quot;employeeService&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeService</span></span><br></pre></td></tr></table></figure>\n\n<p>到此，发现使用@Transactional 注解管理事务的实现步骤其实很简单。</p>\n<p>但是如果对 Spring 中的<code> @Transactional</code> 注解的事务管理理解的不够透彻，就很容易出现错误，比如事务应该回滚（rollback）而没有回滚事务的问题。</p>\n<p>下面看一看注册的事务实现的机制和常见的问题及解决方案。</p>\n</div><div class=\"story post-story\"><h2 id=\"Spring-的注解方式的事务实现机制\"><a href=\"#Spring-的注解方式的事务实现机制\" class=\"headerlink\" title=\"Spring 的注解方式的事务实现机制\"></a>Spring 的注解方式的事务实现机制</h2><p>在应用系统调用声明<code>@Transactional</code> 的目标方法时，<code>Spring Framework</code> 默认使用 <code>AOP</code> 代理，在代码运行时生成一个代理对象，根据<code>@Transactional </code>的属性配置信息，这个代理对象决定该声明@Transactional 的目标方法是否由拦截器<code> TransactionInterceptor</code> 来使用拦截，在 <code>TransactionInterceptor </code>拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器(图 2 有相关介绍)<code>AbstractPlatformTransactionManager </code>操作数据源 <code>DataSource</code> 提交或回滚事务, 如图 1 所示。</p>\n<h5 id=\"图-1-Spring-事务实现机制\"><a href=\"#图-1-Spring-事务实现机制\" class=\"headerlink\" title=\"图 1. Spring 事务实现机制\"></a>图 1. Spring 事务实现机制</h5><p><img src=\"https://imagecdn.bosong.online/blog/image001.jpg\" class=\"lazyload\" data-srcset=\"https://imagecdn.bosong.online/blog/image001.jpg\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" alt=\"img\"></p>\n<p><code>Spring AOP</code> 代理有 <code>CglibAopProxy </code>和<code> JdkDynamicAopProxy</code> 两种，图 1 是以<code>CglibAopProxy</code>为例，对于 <code>CglibAopProxy</code>，需要调用其内部类的 <code>DynamicAdvisedInterceptor </code>的 <code>intercept </code>方法。对于<code> JdkDynamicAopProxy</code>，需要调用其 invoke 方法。</p>\n<p>正如上文提到的，事务管理的框架是由抽象事务管理器 <code>AbstractPlatformTransactionManager</code> 来提供的，而具体的底层事务处理实现，由 <code>PlatformTransactionManager </code>的具体实现类来实现，如事务管理器<code> DataSourceTransactionManager</code>。不同的事务管理器管理不同的数据资源 <code>DataSource</code>，比如 <code>DataSourceTransactionManager</code> 管理<code> JDBC</code> 的 <code>Connection</code>。</p>\n<p><code>PlatformTransactionManager</code>，<code>AbstractPlatformTransactionManager</code> 及具体实现类关系如图 2 所示。</p>\n<h5 id=\"图-2-TransactionManager-类结构\"><a href=\"#图-2-TransactionManager-类结构\" class=\"headerlink\" title=\"图 2. TransactionManager 类结构\"></a>图 2. <code>TransactionManager</code> 类结构</h5><p><img src=\"https://imagecdn.bosong.online/blog/image002.jpg\" class=\"lazyload\" data-srcset=\"https://imagecdn.bosong.online/blog/image002.jpg\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" alt=\"img\"></p>\n</div><div class=\"story post-story\"><h2 id=\"注解方式的事务使用注意事项\"><a href=\"#注解方式的事务使用注意事项\" class=\"headerlink\" title=\"注解方式的事务使用注意事项\"></a>注解方式的事务使用注意事项</h2><p>当您对 Spring 的基于注解方式的实现步骤和事务内在实现机制有较好的理解之后，就会更好的使用注解方式的事务管理，避免当系统抛出异常，数据不能回滚的问题。</p>\n<h3 id=\"正确的设置-Transactional-的-propagation-属性\"><a href=\"#正确的设置-Transactional-的-propagation-属性\" class=\"headerlink\" title=\"正确的设置@Transactional 的 propagation 属性\"></a>正确的设置<code>@Transactional</code> 的 <code>propagation</code> 属性</h3><p>需要注意下面三种 propagation 可以不启动事务。本来期望目标方法进行事务管理，但若是错误的配置这三种 propagation，事务将不会发生回滚。</p>\n<ol>\n<li>SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>\n<li>NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>\n<li>NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li>\n</ol>\n<h3 id=\"正确的设置-Transactional-的-rollbackFor-属性\"><a href=\"#正确的设置-Transactional-的-rollbackFor-属性\" class=\"headerlink\" title=\"正确的设置@Transactional 的 rollbackFor 属性\"></a>正确的设置<code>@Transactional</code> 的 <code>rollbackFor</code> 属性</h3><p>默认情况下，如果在事务中抛出了未检查异常（继承自 <code>RuntimeException </code>的异常）或者 <code>Error</code>，则 Spring 将回滚事务；除此之外，Spring 不会回滚事务。</p>\n<p>如果在事务中抛出其他类型的异常，并期望 Spring 能够回滚事务，可以指定<code> rollbackFor</code>。例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class)</span></span><br></pre></td></tr></table></figure>\n\n<p>通过分析 Spring 源码可以知道，若在目标方法中抛出的异常是<code> rollbackFor</code> 指定的异常的子类，事务同样会回滚。</p>\n<h5 id=\"三、-RollbackRuleAttribute-的-getDepth-方法\"><a href=\"#三、-RollbackRuleAttribute-的-getDepth-方法\" class=\"headerlink\" title=\"三、 RollbackRuleAttribute 的 getDepth 方法\"></a>三、 <code>RollbackRuleAttribute</code> 的 <code>getDepth</code> 方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">getDepth</span><span class=\"params\">(Class&lt;?&gt; exceptionClass, <span class=\"type\">int</span> depth)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exceptionClass.getName().contains(<span class=\"built_in\">this</span>.exceptionName)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Found it!</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// If we&#x27;ve gone as far as we can go and haven&#x27;t found it...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exceptionClass == Throwable.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getDepth(exceptionClass.getSuperclass(), depth + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Transactional-只能应用到-public-方法才有效\"><a href=\"#Transactional-只能应用到-public-方法才有效\" class=\"headerlink\" title=\"@Transactional 只能应用到 public 方法才有效\"></a>@Transactional 只能应用到 public 方法才有效</h3><p>只有@Transactional 注解应用到 public 方法，才能进行事务管理。这是因为在使用 <code>Spring AOP</code> 代理时，Spring 在调用在图 1 中的 <code>TransactionInterceptor</code> 在目标方法执行前后进行拦截之前，<code>DynamicAdvisedInterceptor</code>（<code>CglibAopProxy</code> 的内部类）的的 <code>intercept </code>方法或 <code>JdkDynamicAopProxy</code> 的 <code>invoke</code> 方法会间接调用 <code>AbstractFallbackTransactionAttributeSource</code>（Spring 通过这个类获取表 1. @Transactional 注解的事务属性配置属性信息）的 <code>computeTransactionAttribute</code> 方法。</p>\n<h4 id=\"四、-AbstractFallbackTransactionAttributeSource\"><a href=\"#四、-AbstractFallbackTransactionAttributeSource\" class=\"headerlink\" title=\"四、 AbstractFallbackTransactionAttributeSource\"></a>四、 <code>AbstractFallbackTransactionAttributeSource</code></h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> TransactionAttribute <span class=\"title function_\">computeTransactionAttribute</span><span class=\"params\">(Method method,</span></span><br><span class=\"line\"><span class=\"params\">                                                           Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t allow no-public methods as required.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法会检查目标方法的修饰符是不是 <strong>public</strong>，若不是 public，就不会获取<code>@Transactional</code> 的属性配置信息，最终会造成不会用 <code>TransactionInterceptor</code> 来拦截该目标方法进行事务管理。</p>\n<h3 id=\"避免-Spring-的-AOP-的自调用问题\"><a href=\"#避免-Spring-的-AOP-的自调用问题\" class=\"headerlink\" title=\"避免 Spring 的 AOP 的自调用问题\"></a>避免<code> Spring</code> 的 <code>AOP</code> 的自调用问题</h3><p>在<code> Spring</code> 的 <code>AOP</code> 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有<code>@Transactional</code> 注解的方法内部调用有@Transactional 注解的方法，有<code>@Transactional</code> 注解的方法的事务被忽略，不会发生回滚。见下面代码展示。</p>\n<h4 id=\"五、自调用问题举例\"><a href=\"#五、自调用问题举例\" class=\"headerlink\" title=\"五、自调用问题举例\"></a>五、自调用问题举例</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insertOrder</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;insert&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//一、调用时@Transactional不生效</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        insertOrder();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//二、调用时@Transactional生效</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        ((OrderService) AopContext.currentProxy()).insertOrder();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>insertOrder</code> 尽管有<code>@Transactional</code> 注解，但它被内部方法 <code>insert</code> 调用（一、调用时@Transactional不生效），事务被忽略，出现异常事务不会发生回滚。</p>\n<p>上面的两个问题<code>@Transactional </code>注解只应用到 public 方法和自调用问题，是由于使用 <code>Spring AOP</code> 代理造成的。为解决这两个问题，使用<code> AspectJ</code> 取代 <code>Spring AOP</code> 代理(二、调用时@Transactional生效)。</p>\n<p>需要将下面的<code>AspectJ</code>信息添加到 <code>xml</code> 配置信息中。</p>\n<h4 id=\"六、-AspectJ-的-xml-配置信息\"><a href=\"#六、-AspectJ-的-xml-配置信息\" class=\"headerlink\" title=\"六、 AspectJ 的 xml 配置信息\"></a>六、 <code>AspectJ</code> 的<code> xml</code> 配置信息</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">mode</span>=<span class=\"string\">&quot;aspectj&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;transactionManager&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">&lt;/bean</span><br><span class=\"line\">\tclass=&quot;org.springframework.transaction.aspectj.AnnotationTransactionAspect&quot;</span><br><span class=\"line\">\tfactory-method=&quot;aspectOf&quot;&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;transactionManager&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;transactionManager&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</div><div class=\"story post-story\"><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>关于Spring的事务主要使用的是声明式的方法，事务使用前需要进行配置相关的事务并且如果需要使用到<code>AOP</code>还需要进行<code>AOP</code>的相关配置，然后需要根据具体的需求选用不同的传播行为与隔离级别，还需要注意如果在内部类中调用方法，需要注意<code>@Transactional </code>不会生效的问题，避开了这些问题，使用起事务来就更加如鱼得水。</p>\n<p>参考： <a href=\"https://www.ibm.com/\">https://www.ibm.com/</a> </p>\n\n</div>","more":"<div class=\"story post-story\"><h2 id=\"Spring-的注解方式的事务实现机制\"><a href=\"#Spring-的注解方式的事务实现机制\" class=\"headerlink\" title=\"Spring 的注解方式的事务实现机制\"></a>Spring 的注解方式的事务实现机制</h2><p>在应用系统调用声明<code>@Transactional</code> 的目标方法时，<code>Spring Framework</code> 默认使用 <code>AOP</code> 代理，在代码运行时生成一个代理对象，根据<code>@Transactional </code>的属性配置信息，这个代理对象决定该声明@Transactional 的目标方法是否由拦截器<code> TransactionInterceptor</code> 来使用拦截，在 <code>TransactionInterceptor </code>拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器(图 2 有相关介绍)<code>AbstractPlatformTransactionManager </code>操作数据源 <code>DataSource</code> 提交或回滚事务, 如图 1 所示。</p>\n<h5 id=\"图-1-Spring-事务实现机制\"><a href=\"#图-1-Spring-事务实现机制\" class=\"headerlink\" title=\"图 1. Spring 事务实现机制\"></a>图 1. Spring 事务实现机制</h5><p><img src=\"https://imagecdn.bosong.online/blog/image001.jpg\" class=\"lazyload\" data-srcset=\"https://imagecdn.bosong.online/blog/image001.jpg\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" alt=\"img\"></p>\n<p><code>Spring AOP</code> 代理有 <code>CglibAopProxy </code>和<code> JdkDynamicAopProxy</code> 两种，图 1 是以<code>CglibAopProxy</code>为例，对于 <code>CglibAopProxy</code>，需要调用其内部类的 <code>DynamicAdvisedInterceptor </code>的 <code>intercept </code>方法。对于<code> JdkDynamicAopProxy</code>，需要调用其 invoke 方法。</p>\n<p>正如上文提到的，事务管理的框架是由抽象事务管理器 <code>AbstractPlatformTransactionManager</code> 来提供的，而具体的底层事务处理实现，由 <code>PlatformTransactionManager </code>的具体实现类来实现，如事务管理器<code> DataSourceTransactionManager</code>。不同的事务管理器管理不同的数据资源 <code>DataSource</code>，比如 <code>DataSourceTransactionManager</code> 管理<code> JDBC</code> 的 <code>Connection</code>。</p>\n<p><code>PlatformTransactionManager</code>，<code>AbstractPlatformTransactionManager</code> 及具体实现类关系如图 2 所示。</p>\n<h5 id=\"图-2-TransactionManager-类结构\"><a href=\"#图-2-TransactionManager-类结构\" class=\"headerlink\" title=\"图 2. TransactionManager 类结构\"></a>图 2. <code>TransactionManager</code> 类结构</h5><p><img src=\"https://imagecdn.bosong.online/blog/image002.jpg\" class=\"lazyload\" data-srcset=\"https://imagecdn.bosong.online/blog/image002.jpg\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" alt=\"img\"></p>\n</div><div class=\"story post-story\"><h2 id=\"注解方式的事务使用注意事项\"><a href=\"#注解方式的事务使用注意事项\" class=\"headerlink\" title=\"注解方式的事务使用注意事项\"></a>注解方式的事务使用注意事项</h2><p>当您对 Spring 的基于注解方式的实现步骤和事务内在实现机制有较好的理解之后，就会更好的使用注解方式的事务管理，避免当系统抛出异常，数据不能回滚的问题。</p>\n<h3 id=\"正确的设置-Transactional-的-propagation-属性\"><a href=\"#正确的设置-Transactional-的-propagation-属性\" class=\"headerlink\" title=\"正确的设置@Transactional 的 propagation 属性\"></a>正确的设置<code>@Transactional</code> 的 <code>propagation</code> 属性</h3><p>需要注意下面三种 propagation 可以不启动事务。本来期望目标方法进行事务管理，但若是错误的配置这三种 propagation，事务将不会发生回滚。</p>\n<ol>\n<li>SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>\n<li>NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>\n<li>NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li>\n</ol>\n<h3 id=\"正确的设置-Transactional-的-rollbackFor-属性\"><a href=\"#正确的设置-Transactional-的-rollbackFor-属性\" class=\"headerlink\" title=\"正确的设置@Transactional 的 rollbackFor 属性\"></a>正确的设置<code>@Transactional</code> 的 <code>rollbackFor</code> 属性</h3><p>默认情况下，如果在事务中抛出了未检查异常（继承自 <code>RuntimeException </code>的异常）或者 <code>Error</code>，则 Spring 将回滚事务；除此之外，Spring 不会回滚事务。</p>\n<p>如果在事务中抛出其他类型的异常，并期望 Spring 能够回滚事务，可以指定<code> rollbackFor</code>。例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class)</span></span><br></pre></td></tr></table></figure>\n\n<p>通过分析 Spring 源码可以知道，若在目标方法中抛出的异常是<code> rollbackFor</code> 指定的异常的子类，事务同样会回滚。</p>\n<h5 id=\"三、-RollbackRuleAttribute-的-getDepth-方法\"><a href=\"#三、-RollbackRuleAttribute-的-getDepth-方法\" class=\"headerlink\" title=\"三、 RollbackRuleAttribute 的 getDepth 方法\"></a>三、 <code>RollbackRuleAttribute</code> 的 <code>getDepth</code> 方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">getDepth</span><span class=\"params\">(Class&lt;?&gt; exceptionClass, <span class=\"type\">int</span> depth)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exceptionClass.getName().contains(<span class=\"built_in\">this</span>.exceptionName)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Found it!</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// If we&#x27;ve gone as far as we can go and haven&#x27;t found it...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exceptionClass == Throwable.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getDepth(exceptionClass.getSuperclass(), depth + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Transactional-只能应用到-public-方法才有效\"><a href=\"#Transactional-只能应用到-public-方法才有效\" class=\"headerlink\" title=\"@Transactional 只能应用到 public 方法才有效\"></a>@Transactional 只能应用到 public 方法才有效</h3><p>只有@Transactional 注解应用到 public 方法，才能进行事务管理。这是因为在使用 <code>Spring AOP</code> 代理时，Spring 在调用在图 1 中的 <code>TransactionInterceptor</code> 在目标方法执行前后进行拦截之前，<code>DynamicAdvisedInterceptor</code>（<code>CglibAopProxy</code> 的内部类）的的 <code>intercept </code>方法或 <code>JdkDynamicAopProxy</code> 的 <code>invoke</code> 方法会间接调用 <code>AbstractFallbackTransactionAttributeSource</code>（Spring 通过这个类获取表 1. @Transactional 注解的事务属性配置属性信息）的 <code>computeTransactionAttribute</code> 方法。</p>\n<h4 id=\"四、-AbstractFallbackTransactionAttributeSource\"><a href=\"#四、-AbstractFallbackTransactionAttributeSource\" class=\"headerlink\" title=\"四、 AbstractFallbackTransactionAttributeSource\"></a>四、 <code>AbstractFallbackTransactionAttributeSource</code></h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> TransactionAttribute <span class=\"title function_\">computeTransactionAttribute</span><span class=\"params\">(Method method,</span></span><br><span class=\"line\"><span class=\"params\">                                                           Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Don&#x27;t allow no-public methods as required.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法会检查目标方法的修饰符是不是 <strong>public</strong>，若不是 public，就不会获取<code>@Transactional</code> 的属性配置信息，最终会造成不会用 <code>TransactionInterceptor</code> 来拦截该目标方法进行事务管理。</p>\n<h3 id=\"避免-Spring-的-AOP-的自调用问题\"><a href=\"#避免-Spring-的-AOP-的自调用问题\" class=\"headerlink\" title=\"避免 Spring 的 AOP 的自调用问题\"></a>避免<code> Spring</code> 的 <code>AOP</code> 的自调用问题</h3><p>在<code> Spring</code> 的 <code>AOP</code> 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有<code>@Transactional</code> 注解的方法内部调用有@Transactional 注解的方法，有<code>@Transactional</code> 注解的方法的事务被忽略，不会发生回滚。见下面代码展示。</p>\n<h4 id=\"五、自调用问题举例\"><a href=\"#五、自调用问题举例\" class=\"headerlink\" title=\"五、自调用问题举例\"></a>五、自调用问题举例</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insertOrder</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;insert&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//一、调用时@Transactional不生效</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        insertOrder();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//二、调用时@Transactional生效</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        ((OrderService) AopContext.currentProxy()).insertOrder();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>insertOrder</code> 尽管有<code>@Transactional</code> 注解，但它被内部方法 <code>insert</code> 调用（一、调用时@Transactional不生效），事务被忽略，出现异常事务不会发生回滚。</p>\n<p>上面的两个问题<code>@Transactional </code>注解只应用到 public 方法和自调用问题，是由于使用 <code>Spring AOP</code> 代理造成的。为解决这两个问题，使用<code> AspectJ</code> 取代 <code>Spring AOP</code> 代理(二、调用时@Transactional生效)。</p>\n<p>需要将下面的<code>AspectJ</code>信息添加到 <code>xml</code> 配置信息中。</p>\n<h4 id=\"六、-AspectJ-的-xml-配置信息\"><a href=\"#六、-AspectJ-的-xml-配置信息\" class=\"headerlink\" title=\"六、 AspectJ 的 xml 配置信息\"></a>六、 <code>AspectJ</code> 的<code> xml</code> 配置信息</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">mode</span>=<span class=\"string\">&quot;aspectj&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;transactionManager&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">&lt;/bean</span><br><span class=\"line\">\tclass=&quot;org.springframework.transaction.aspectj.AnnotationTransactionAspect&quot;</span><br><span class=\"line\">\tfactory-method=&quot;aspectOf&quot;&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;transactionManager&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;transactionManager&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</div><div class=\"story post-story\"><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>关于Spring的事务主要使用的是声明式的方法，事务使用前需要进行配置相关的事务并且如果需要使用到<code>AOP</code>还需要进行<code>AOP</code>的相关配置，然后需要根据具体的需求选用不同的传播行为与隔离级别，还需要注意如果在内部类中调用方法，需要注意<code>@Transactional </code>不会生效的问题，避开了这些问题，使用起事务来就更加如鱼得水。</p>\n<p>参考： <a href=\"https://www.ibm.com/\">https://www.ibm.com/</a> </p>\n\n</div>","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"Spring","path":"api/tags/Spring.json"}]}