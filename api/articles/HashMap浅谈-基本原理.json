{"title":"HashMap浅谈-基本原理","slug":"HashMap浅谈-基本原理","date":"2020-06-22T14:27:40.000Z","updated":"2022-06-02T01:05:59.612Z","comments":true,"path":"api/articles/HashMap浅谈-基本原理.json","excerpt":"HashMap的组成HashMap的内部实现是一个数组，但是它是一个特殊的数组。如下图所示：<br> [Figure] ","covers":["https://imagecdn.bosong.online/blog/2020/HashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"],"content":"<h4 id=\"HashMap的组成\"><a href=\"#HashMap的组成\" class=\"headerlink\" title=\"HashMap的组成\"></a>HashMap的组成</h4><p>HashMap的内部实现是一个数组，但是它是一个特殊的数组。如下图所示：<br><img src=\"https://imagecdn.bosong.online/blog/2020/HashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png\" class=\"lazyload\" data-srcset=\"https://imagecdn.bosong.online/blog/2020/HashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" alt=\"HashMap数据结构\"></p>\n<h4 id=\"HashMap的内部结构\"><a href=\"#HashMap的内部结构\" class=\"headerlink\" title=\"HashMap的内部结构\"></a>HashMap的内部结构</h4><p>HashMap是一个特殊的数组实现，它的数据插入并不是按照顺序逐个写入的，而是按照一种特定算法来确定写入的位置，</p>\n<p>然后将对象进行写入，它就是散列计算，就是计算出当前key的hash值，然后对hash值做一定的操作，再计算出当前的hash对应的是哪个桶，然后再将对应的输入写入到桶内（栗子：上图中的Node1节点）</p>\n<p>当存在同hash值时，同一个桶内的数据会采用拉链法来使桶内的数据形成一个链表结构，这样同hash的值都会保存并且不会覆盖。</p>\n<p>当链表长度达到一定的阈值时（阈值：8），为了提高它的性能，此时会将链表转化为红黑树进行存储（栗子:上图中的Node2节点）</p>\n<h4 id=\"HashMap的核心概念\"><a href=\"#HashMap的核心概念\" class=\"headerlink\" title=\"HashMap的核心概念\"></a>HashMap的核心概念</h4><ol>\n<li><p>HashMap的存储结构</p>\n<p>HashMap的底层实现是一个数组,源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The table, initialized on first use, and resized as</span></span><br><span class=\"line\"><span class=\"comment\">     * necessary. When allocated, length is always a power of two.</span></span><br><span class=\"line\"><span class=\"comment\">     * (We also tolerate length zero in some operations to allow</span></span><br><span class=\"line\"><span class=\"comment\">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HashMap的存储节点</p>\n</li>\n</ol>\n<ul>\n<li><p>HashMap在存储时是一个table,它在正常情况下的基础元素组成是一个Node</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class=\"line\"><span class=\"comment\">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> hash;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        Node&lt;K,V&gt; next;</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>table在链表长度达到8或者8以上时，会转化为红黑树，变成了一个TreeNode</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class=\"line\"><span class=\"comment\"> * extends Node) so can be used as extension of either regular or</span></span><br><span class=\"line\"><span class=\"comment\"> * linked node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TreeNode</span>&lt;K,V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// red-black tree links</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// needed to unlink next upon deletion</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> red;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>HashMap的容量<br> HashMap的容量指的是它的table长度，也就是bin(桶)的数量，当桶的数量达到阈值时，它会扩充容量。</li>\n</ol>\n<p>  容量值的<strong>初始化数值必须是2的幂次方</strong>，它的<strong>最大容量是2的30次方</strong>。当传入的容量值不为2的幂次方时，它会自动转化为大于当前数值的最近的2的幂次方。</p>\n<p>  table长度定义：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// (The javadoc description is true upon serialization.</span></span><br><span class=\"line\"><span class=\"comment\">// Additionally, if the table array has not been allocated, this</span></span><br><span class=\"line\"><span class=\"comment\">// field holds the initial array capacity, or zero signifying</span></span><br><span class=\"line\"><span class=\"comment\">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class=\"line\"><span class=\"type\">int</span> threshold;</span><br></pre></td></tr></table></figure>\n\n<p>  负载因子定义：</p>\n<p>  负载因子是一个系数，它与容量参数结合使用，一般不会进行改动，它的默认值是：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The load factor used when none specified in constructor.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">float</span> <span class=\"variable\">DEFAULT_LOAD_FACTOR</span> <span class=\"operator\">=</span> <span class=\"number\">0.75f</span>;</span><br></pre></td></tr></table></figure>\n\n<p>  阈值计算公式：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">阈值 = threshold * DEFAULT_LOAD_FACTOR;</span><br></pre></td></tr></table></figure>\n\n<p>  如果当前的容量是1024，那么它的阈值就是1024*0.75&#x3D;768,当当前HashMap的实际使用容量达到了768时，它会触发扩容操作，扩容的大小为当前容量的两倍大小：2048。</p>\n<p>  扩容计算公式：</p>\n<p>  <strong>容量 &#x3D; 当前容量 * 2</strong></p>\n<p>  扩容原理：</p>\n<p>  <strong>扩容时，会创建一个2当前容量2倍大数组，然后将原来的数组内容copy进新的数组中，将table替换为新的数组，此时就达到了扩容的目的。</strong><br>4. HashMap的元素个数</p>\n<p>   在HaspMap中，它的容量不等同于元素个数，它的元素个数定义是：</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The number of key-value mappings contained in this map.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"type\">int</span> size;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"注意的点\"><a href=\"#注意的点\" class=\"headerlink\" title=\"注意的点\"></a>注意的点</h4><h5 id=\"Java7之前和Java8之后的扩容机制是不一致的\"><a href=\"#Java7之前和Java8之后的扩容机制是不一致的\" class=\"headerlink\" title=\"Java7之前和Java8之后的扩容机制是不一致的\"></a>Java7之前和Java8之后的扩容机制是不一致的</h5><p>Java7之前，扩容的因素需要满足两个条件：</p>\n<p>1、当前的键值对数量大于当前阈值</p>\n<p>2、新增加的键值对发送了hash碰撞</p>\n<p>此时会出现两种情况（默认的容量为16）</p>\n<p>1、当键值对数量在16时，才会触发扩容机制，此时的情况是前16个元素都没有发生hash碰撞，全部都放置在不同的桶中，到第17个元素插入时，才会完全满足以上两个条件，触发扩容</p>\n<p>2、键值对可能在达到26个时，才会触发扩容机制，此时的情况是前11个元素全部发送了hash碰撞，存储在同一个桶中，后面的15个元素全部都没有发生hash碰撞，到第27个元素插入时才会满足以上两个条件，触发扩容</p>\n<p>Java8之后，扩容的因素只需要满足一个条件</p>\n<p>1、当前插入的元素为新值（不包括同键值，但是值不同的情况），并且已有键值对个数达到阈值时</p>\n<h5 id=\"Node的引入是在Java8之后\"><a href=\"#Node的引入是在Java8之后\" class=\"headerlink\" title=\"Node的引入是在Java8之后\"></a>Node的引入是在Java8之后</h5><p>Java7之前的节点是Entry,它的结构桶结构除了单节点就是链表，没有红黑树</p>\n<p>在Java8之后的节点发生了改变，使用Node节点，在Node节点数为8以下的形成链表，当到达8时，会转变成红黑树结构，提高查询效率</p>\n<h5 id=\"HashMap的查询效率\"><a href=\"#HashMap的查询效率\" class=\"headerlink\" title=\"HashMap的查询效率\"></a>HashMap的查询效率</h5><p>HashMap的查询效率是O(1)，查询非常快</p>\n\n","more":"\n<h4 id=\"HashMap的内部结构\"><a href=\"#HashMap的内部结构\" class=\"headerlink\" title=\"HashMap的内部结构\"></a>HashMap的内部结构</h4><p>HashMap是一个特殊的数组实现，它的数据插入并不是按照顺序逐个写入的，而是按照一种特定算法来确定写入的位置，</p>\n<p>然后将对象进行写入，它就是散列计算，就是计算出当前key的hash值，然后对hash值做一定的操作，再计算出当前的hash对应的是哪个桶，然后再将对应的输入写入到桶内（栗子：上图中的Node1节点）</p>\n<p>当存在同hash值时，同一个桶内的数据会采用拉链法来使桶内的数据形成一个链表结构，这样同hash的值都会保存并且不会覆盖。</p>\n<p>当链表长度达到一定的阈值时（阈值：8），为了提高它的性能，此时会将链表转化为红黑树进行存储（栗子:上图中的Node2节点）</p>\n<h4 id=\"HashMap的核心概念\"><a href=\"#HashMap的核心概念\" class=\"headerlink\" title=\"HashMap的核心概念\"></a>HashMap的核心概念</h4><ol>\n<li><p>HashMap的存储结构</p>\n<p>HashMap的底层实现是一个数组,源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The table, initialized on first use, and resized as</span></span><br><span class=\"line\"><span class=\"comment\">     * necessary. When allocated, length is always a power of two.</span></span><br><span class=\"line\"><span class=\"comment\">     * (We also tolerate length zero in some operations to allow</span></span><br><span class=\"line\"><span class=\"comment\">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HashMap的存储节点</p>\n</li>\n</ol>\n<ul>\n<li><p>HashMap在存储时是一个table,它在正常情况下的基础元素组成是一个Node</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class=\"line\"><span class=\"comment\">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> hash;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        Node&lt;K,V&gt; next;</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>table在链表长度达到8或者8以上时，会转化为红黑树，变成了一个TreeNode</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class=\"line\"><span class=\"comment\"> * extends Node) so can be used as extension of either regular or</span></span><br><span class=\"line\"><span class=\"comment\"> * linked node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TreeNode</span>&lt;K,V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// red-black tree links</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// needed to unlink next upon deletion</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> red;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>HashMap的容量<br> HashMap的容量指的是它的table长度，也就是bin(桶)的数量，当桶的数量达到阈值时，它会扩充容量。</li>\n</ol>\n<p>  容量值的<strong>初始化数值必须是2的幂次方</strong>，它的<strong>最大容量是2的30次方</strong>。当传入的容量值不为2的幂次方时，它会自动转化为大于当前数值的最近的2的幂次方。</p>\n<p>  table长度定义：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// (The javadoc description is true upon serialization.</span></span><br><span class=\"line\"><span class=\"comment\">// Additionally, if the table array has not been allocated, this</span></span><br><span class=\"line\"><span class=\"comment\">// field holds the initial array capacity, or zero signifying</span></span><br><span class=\"line\"><span class=\"comment\">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class=\"line\"><span class=\"type\">int</span> threshold;</span><br></pre></td></tr></table></figure>\n\n<p>  负载因子定义：</p>\n<p>  负载因子是一个系数，它与容量参数结合使用，一般不会进行改动，它的默认值是：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The load factor used when none specified in constructor.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">float</span> <span class=\"variable\">DEFAULT_LOAD_FACTOR</span> <span class=\"operator\">=</span> <span class=\"number\">0.75f</span>;</span><br></pre></td></tr></table></figure>\n\n<p>  阈值计算公式：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">阈值 = threshold * DEFAULT_LOAD_FACTOR;</span><br></pre></td></tr></table></figure>\n\n<p>  如果当前的容量是1024，那么它的阈值就是1024*0.75&#x3D;768,当当前HashMap的实际使用容量达到了768时，它会触发扩容操作，扩容的大小为当前容量的两倍大小：2048。</p>\n<p>  扩容计算公式：</p>\n<p>  <strong>容量 &#x3D; 当前容量 * 2</strong></p>\n<p>  扩容原理：</p>\n<p>  <strong>扩容时，会创建一个2当前容量2倍大数组，然后将原来的数组内容copy进新的数组中，将table替换为新的数组，此时就达到了扩容的目的。</strong><br>4. HashMap的元素个数</p>\n<p>   在HaspMap中，它的容量不等同于元素个数，它的元素个数定义是：</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The number of key-value mappings contained in this map.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"type\">int</span> size;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"注意的点\"><a href=\"#注意的点\" class=\"headerlink\" title=\"注意的点\"></a>注意的点</h4><h5 id=\"Java7之前和Java8之后的扩容机制是不一致的\"><a href=\"#Java7之前和Java8之后的扩容机制是不一致的\" class=\"headerlink\" title=\"Java7之前和Java8之后的扩容机制是不一致的\"></a>Java7之前和Java8之后的扩容机制是不一致的</h5><p>Java7之前，扩容的因素需要满足两个条件：</p>\n<p>1、当前的键值对数量大于当前阈值</p>\n<p>2、新增加的键值对发送了hash碰撞</p>\n<p>此时会出现两种情况（默认的容量为16）</p>\n<p>1、当键值对数量在16时，才会触发扩容机制，此时的情况是前16个元素都没有发生hash碰撞，全部都放置在不同的桶中，到第17个元素插入时，才会完全满足以上两个条件，触发扩容</p>\n<p>2、键值对可能在达到26个时，才会触发扩容机制，此时的情况是前11个元素全部发送了hash碰撞，存储在同一个桶中，后面的15个元素全部都没有发生hash碰撞，到第27个元素插入时才会满足以上两个条件，触发扩容</p>\n<p>Java8之后，扩容的因素只需要满足一个条件</p>\n<p>1、当前插入的元素为新值（不包括同键值，但是值不同的情况），并且已有键值对个数达到阈值时</p>\n<h5 id=\"Node的引入是在Java8之后\"><a href=\"#Node的引入是在Java8之后\" class=\"headerlink\" title=\"Node的引入是在Java8之后\"></a>Node的引入是在Java8之后</h5><p>Java7之前的节点是Entry,它的结构桶结构除了单节点就是链表，没有红黑树</p>\n<p>在Java8之后的节点发生了改变，使用Node节点，在Node节点数为8以下的形成链表，当到达8时，会转变成红黑树结构，提高查询效率</p>\n<h5 id=\"HashMap的查询效率\"><a href=\"#HashMap的查询效率\" class=\"headerlink\" title=\"HashMap的查询效率\"></a>HashMap的查询效率</h5><p>HashMap的查询效率是O(1)，查询非常快</p>\n\n","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"}]}