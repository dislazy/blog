{"title":"HashMap浅谈-基本方法","slug":"HashMap浅谈-基本方法","date":"2020-06-24T12:30:36.000Z","updated":"2022-06-02T01:05:59.613Z","comments":true,"path":"api/articles/HashMap浅谈-基本方法.json","excerpt":"HashMap的初始化过程HashMap的初始化有两种方法：","covers":null,"content":"<h4 id=\"HashMap的初始化过程\"><a href=\"#HashMap的初始化过程\" class=\"headerlink\" title=\"HashMap的初始化过程\"></a>HashMap的初始化过程</h4><p>HashMap的初始化有两种方法：</p>\n<ol>\n<li><p>直接使用HashMap的无参构造方法，此时初始化的容量为：DEFAULT_LOAD_FACTOR 也就是16</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class=\"line\"><span class=\"comment\">     * (16) and the default load factor (0.75).</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HashMap</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class=\"comment\">// all other fields defaulted</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传入容量参数的有参构造方法，此时的初始化容量需要进行计算</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class=\"line\"><span class=\"comment\"> * capacity and the default load factor (0.75).</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  initialCapacity the initial capacity.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HashMap</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t上一文中提到，HashMap的容量必须为2的幂次方，但是不是所有的同学在创建Map的时候都会遵守这个规则，在这种情况下，HashMap也会对传入的参数进行校准，规则是将  <strong>参数值转换为最接近、且大于等于指定参数的 2 的 幂次方的值</strong>，它确保了HashMap不管是在<strong>初始化</strong>时，或者在<strong>扩容</strong>时，它的容量一直<strong>保持的是2的幂次方的值</strong>，具体方法可以参考：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">tableSizeFor</span><span class=\"params\">(<span class=\"type\">int</span> cap)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HashMap的基本方法及原理\"><a href=\"#HashMap的基本方法及原理\" class=\"headerlink\" title=\"HashMap的基本方法及原理\"></a>HashMap的基本方法及原理</h4><h5 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h5><p>   put方法是HashMap的一个基本方法，它的算法也是非常的复杂的，涉及到了单个节点、链表节点、红黑树节点，容量达到阈值时的自动扩容等。</p>\n<p>   它的原理主要包括下面几个方面：</p>\n<ul>\n<li><p>HashMap的扩容阈值，以及扩容过程</p>\n<p>扩容阈值 &#x3D; 当前容量 * 扩容因子 </p>\n<p>扩容基本上分为几步：</p>\n<p>1、创建一个为原来两倍大的数组</p>\n<p>2、复制原有数组的数据，该转化为链表的转化为链表，该转化为红黑树的转化为红黑树</p>\n</li>\n<li><p>插入键值对时如何确定落在哪个桶中（它虽然是个数组，但不是纯粹的数组）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class=\"line\"><span class=\"comment\">     * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class=\"line\"><span class=\"comment\">     * hashes that vary only in bits above the current mask will</span></span><br><span class=\"line\"><span class=\"comment\">     * always collide. (Among known examples are sets of Float keys</span></span><br><span class=\"line\"><span class=\"comment\">     * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class=\"line\"><span class=\"comment\">     * apply a transform that spreads the impact of higher bits</span></span><br><span class=\"line\"><span class=\"comment\">     * downward. There is a tradeoff between speed, utility, and</span></span><br><span class=\"line\"><span class=\"comment\">     * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class=\"line\"><span class=\"comment\">     * are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class=\"line\"><span class=\"comment\">     * spreading), and because we use trees to handle large sets of</span></span><br><span class=\"line\"><span class=\"comment\">     * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class=\"line\"><span class=\"comment\">     * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class=\"line\"><span class=\"comment\">     * to incorporate impact of the highest bits that would otherwise</span></span><br><span class=\"line\"><span class=\"comment\">     * never be used in index calculations because of table bounds.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> h;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\tHashMap在计算hash值时，会将 hashCode 做一次16位右位移，然后将右移的结果和 hashCode 做异或运算，减少Hash碰撞的次数，然后将获取的值存储到对应的hash值的桶中</p>\n</li>\n<li><p>键值的唯一性的保证机制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure>\n\n<p>​\t在java.util.HashMap#putVal中存在这样一段代码，当key的hash值相同并且key的内存位置相同或者key的值相同时，可以确认是同一个key，此时会根据条件来判断是直接将原来的key对应的value替换还是做其他的操作，以此来保证键值的唯一性。</p>\n<p>​\t此处也有一定的坑，因为有一个 <strong>&#x3D;&#x3D;</strong> 当传入的键值为引用对象时，如果没有重写引用对象的hashCode()方法，会导致同样参数的对象被认为是不同的键值，因为如果不重写hashCode()方法时，那么它就继承的是Object的hashCode()方法，Object的hashCode方法获取到的hashCode对每个对象来说都是唯一的， 可以查看下面的例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HashKey</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * Id</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * hashKey</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String hashKey;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Map&lt;HashKey,String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">HashKey</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashKey</span>(<span class=\"number\">1</span>,<span class=\"string\">&quot;10086&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">HashKey</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashKey</span>(<span class=\"number\">1</span>,<span class=\"string\">&quot;10086&quot;</span>);</span><br><span class=\"line\">        map.put(a,<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        map.put(b,<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        System.out.println(JSON.toJSONString(map));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    输出结果：&#123;&#123;<span class=\"string\">&quot;hashKey&quot;</span>:<span class=\"string\">&quot;10086&quot;</span>,<span class=\"string\">&quot;id&quot;</span>:<span class=\"number\">1</span>&#125;:<span class=\"string\">&quot;1&quot;</span>,&#123;<span class=\"string\">&quot;hashKey&quot;</span>:<span class=\"string\">&quot;10086&quot;</span>,<span class=\"string\">&quot;id&quot;</span>:<span class=\"number\">1</span>&#125;:<span class=\"string\">&quot;1&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>所以，如果使用对象做键值对的键值的话，一定记得重写HashCode()方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> Objects.hash(id, hashKey);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">\t\t输出结果：&#123;&#123;<span class=\"string\">&quot;hashKey&quot;</span>:<span class=\"string\">&quot;10086&quot;</span>,<span class=\"string\">&quot;id&quot;</span>:<span class=\"number\">1</span>&#125;:<span class=\"string\">&quot;1&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>发生hash碰撞（不同的键值hash值相同）时的处理机制</p>\n<p>虽然在hash值的计算上都是在极力避免出现hash碰撞的情况，但是hash碰撞还是有可能会发生，那么当hash值相同但是键值不同的键值对该如何存放呢，分为两种情况：</p>\n<p>1、在当前的hash对应的bin下面会创建成一个长度不超过8的链表</p>\n<p>2、当链表长度大于等于8的时候，会转化红黑树，因为红黑树的查询效率是非常高的，但是占用空间会比链表大，典型的使用空间换时间，但是换的物超所值</p>\n</li>\n<li><p>单节点拉链法的实现过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> hash;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        Node&lt;K,V&gt; next;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t代码中的next就是下一个节点，当最后一个节点next为null时，代表着这个链表结束了。</p>\n<p>值得注意的是在JDK7之前链表使用的是头插法（不是使用的Node),当两个线程在执行resize()方法的时候可能会产生环形链表，在调用get()方法会死循环，导致OOM</p>\n</li>\n<li><p>链表转化为红黑树的方法过程</p>\n<p>​\t\t当链表的长度达到8时，已经是一个相对比较长的结构了，这时候查询的效率会随着链表的数量增长而降低，此时为了追求性能最大化，就会将链表转化为红黑树，这时候会产生一个问题：红黑树既然查询效率足够的高，为什么不直接采用红黑树的结构而使用链表达到8时才转变呢？</p>\n<p>这个其实也是有原因的，在一定的范围内，用空间换取时间效率是可取的，当链表长度比较短时，转变成红黑树，空间结构变大了，但是此时查询效率并没有因此而提高，反而得不偿失了，所以当链表达到阈值时来使用红黑树是相对比较划算的一种方案。</p>\n</li>\n</ul>\n<h5 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h5><p>   ​HashMap设计的最主要原因就是为了提高查询效率，get方法是使用的最频繁的一个方法之一，它主要就是靠hash算法获取的值来快速定位到索引，然后返回对应的索引对应值。</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Implements Map.get and related methods.</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return</span> the node, or null if none</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title function_\">getNode</span><span class=\"params\">(<span class=\"type\">int</span> hash, Object key)</span> &#123;</span><br><span class=\"line\">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"type\">int</span> n; K k;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((tab = table) != <span class=\"literal\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">          (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">              ((k = first.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">              <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">              <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                      ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                      <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>   ​\tget方法主要包含以下几个过程</p>\n<p>   ​\t1、获取key的hash计算参数</p>\n<p>   ​\t2、查找对应索引位置</p>\n<p>   ​\t3、如果是单节点Node直接返回Node,如果是链表Node在链表中获取Node节点，如果是红黑树节点，那么调用红黑树的查询方法快速找到Node并且返回</p>\n<h5 id=\"remove方法\"><a href=\"#remove方法\" class=\"headerlink\" title=\"remove方法\"></a>remove方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```java</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Implements Map.remove and related methods.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> matchValue if true only remove if value is equal</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> movable if false do not move other nodes while removing</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the node, or null if none</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title function_\">removeNode</span><span class=\"params\">(<span class=\"type\">int</span> hash, Object key, Object value,</span></span><br><span class=\"line\"><span class=\"params\">                               <span class=\"type\">boolean</span> matchValue, <span class=\"type\">boolean</span> movable)</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"type\">int</span> n, index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) != <span class=\"literal\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; node = <span class=\"literal\">null</span>, e; K k; V v;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                node = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                            ((k = e.key) == key ||</span><br><span class=\"line\">                             (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">                            node = e;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        p = e;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                                 (value != <span class=\"literal\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"built_in\">this</span>, tab, movable);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)</span><br><span class=\"line\">                    tab[index] = node.next;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    p.next = node.next;</span><br><span class=\"line\">                ++modCount;</span><br><span class=\"line\">                --size;</span><br><span class=\"line\">                afterNodeRemoval(node);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n\n\n\n<p>remove()方法也是个比较特殊的方法，它的作用和put()是完全相反的，基本也分为以下几个过程：</p>\n<p>1、如果是单节点Node，那么直接将对应的Node设置为Null</p>\n<p>2、如果是链表Node，那么将该Node删除的同时，将它前一个Node的next替换为后一个Node，保证链表的连续性</p>\n<p>3、如果是红黑树Node，那么就需要调用红黑树的删除节点方法进行删除了，此时如果红黑树的Node值为2-6个时，会调方法转化为链表结构的Node</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>HashMap是一个数组，但它是一个特殊的数组，包含了多种结构单元：单节点Node、Node链表、红黑树，根据实际情况互相转化，因为它的特殊性，造就了它超高的查询效率，<strong>O(1) 级别的查询效率</strong>，直接根据对应索引的位置找到对象并返回</p>\n<p>HashMap的容量也是有规律的，为了结构的稳定性以及保障索引的散列计算更加均匀，它的容量必须是<strong>2的幂次方</strong>，即使是没有传正确的容量参数，也是会进行校准的</p>\n<p>HashMap的扩容是达到一定阈值后会进行<strong>两倍放大</strong>，创建一个新的数组，将原来对象进行复制，并且会对单节点类型的元素重新计算他们的索引位置，如果是红黑树的话，会根据红黑树特有的方法进行扩容，在红黑树与链表之间进行动态转化</p>\n<p>HashMap和List、Set等集合一样，<strong>不是线程安全的</strong>，它在多线程情况是不具备线程安全特性的，如果同时有多个put或者多个remove会对它的数据造成比较大的影响，多线程环境下不推荐使用HashMap，它在多线程环境的替代是<strong>ConcurrentHashMap</strong>,关于ConcurrentHashMap有时间的还可以深入了解一下。</p>\n\n","more":"\n<ol>\n<li><p>直接使用HashMap的无参构造方法，此时初始化的容量为：DEFAULT_LOAD_FACTOR 也就是16</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class=\"line\"><span class=\"comment\">     * (16) and the default load factor (0.75).</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HashMap</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class=\"comment\">// all other fields defaulted</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传入容量参数的有参构造方法，此时的初始化容量需要进行计算</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class=\"line\"><span class=\"comment\"> * capacity and the default load factor (0.75).</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  initialCapacity the initial capacity.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HashMap</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t上一文中提到，HashMap的容量必须为2的幂次方，但是不是所有的同学在创建Map的时候都会遵守这个规则，在这种情况下，HashMap也会对传入的参数进行校准，规则是将  <strong>参数值转换为最接近、且大于等于指定参数的 2 的 幂次方的值</strong>，它确保了HashMap不管是在<strong>初始化</strong>时，或者在<strong>扩容</strong>时，它的容量一直<strong>保持的是2的幂次方的值</strong>，具体方法可以参考：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">tableSizeFor</span><span class=\"params\">(<span class=\"type\">int</span> cap)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HashMap的基本方法及原理\"><a href=\"#HashMap的基本方法及原理\" class=\"headerlink\" title=\"HashMap的基本方法及原理\"></a>HashMap的基本方法及原理</h4><h5 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h5><p>   put方法是HashMap的一个基本方法，它的算法也是非常的复杂的，涉及到了单个节点、链表节点、红黑树节点，容量达到阈值时的自动扩容等。</p>\n<p>   它的原理主要包括下面几个方面：</p>\n<ul>\n<li><p>HashMap的扩容阈值，以及扩容过程</p>\n<p>扩容阈值 &#x3D; 当前容量 * 扩容因子 </p>\n<p>扩容基本上分为几步：</p>\n<p>1、创建一个为原来两倍大的数组</p>\n<p>2、复制原有数组的数据，该转化为链表的转化为链表，该转化为红黑树的转化为红黑树</p>\n</li>\n<li><p>插入键值对时如何确定落在哪个桶中（它虽然是个数组，但不是纯粹的数组）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class=\"line\"><span class=\"comment\">     * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class=\"line\"><span class=\"comment\">     * hashes that vary only in bits above the current mask will</span></span><br><span class=\"line\"><span class=\"comment\">     * always collide. (Among known examples are sets of Float keys</span></span><br><span class=\"line\"><span class=\"comment\">     * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class=\"line\"><span class=\"comment\">     * apply a transform that spreads the impact of higher bits</span></span><br><span class=\"line\"><span class=\"comment\">     * downward. There is a tradeoff between speed, utility, and</span></span><br><span class=\"line\"><span class=\"comment\">     * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class=\"line\"><span class=\"comment\">     * are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class=\"line\"><span class=\"comment\">     * spreading), and because we use trees to handle large sets of</span></span><br><span class=\"line\"><span class=\"comment\">     * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class=\"line\"><span class=\"comment\">     * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class=\"line\"><span class=\"comment\">     * to incorporate impact of the highest bits that would otherwise</span></span><br><span class=\"line\"><span class=\"comment\">     * never be used in index calculations because of table bounds.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> h;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\tHashMap在计算hash值时，会将 hashCode 做一次16位右位移，然后将右移的结果和 hashCode 做异或运算，减少Hash碰撞的次数，然后将获取的值存储到对应的hash值的桶中</p>\n</li>\n<li><p>键值的唯一性的保证机制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure>\n\n<p>​\t在java.util.HashMap#putVal中存在这样一段代码，当key的hash值相同并且key的内存位置相同或者key的值相同时，可以确认是同一个key，此时会根据条件来判断是直接将原来的key对应的value替换还是做其他的操作，以此来保证键值的唯一性。</p>\n<p>​\t此处也有一定的坑，因为有一个 <strong>&#x3D;&#x3D;</strong> 当传入的键值为引用对象时，如果没有重写引用对象的hashCode()方法，会导致同样参数的对象被认为是不同的键值，因为如果不重写hashCode()方法时，那么它就继承的是Object的hashCode()方法，Object的hashCode方法获取到的hashCode对每个对象来说都是唯一的， 可以查看下面的例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HashKey</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * Id</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * hashKey</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String hashKey;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Map&lt;HashKey,String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">HashKey</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashKey</span>(<span class=\"number\">1</span>,<span class=\"string\">&quot;10086&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">HashKey</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashKey</span>(<span class=\"number\">1</span>,<span class=\"string\">&quot;10086&quot;</span>);</span><br><span class=\"line\">        map.put(a,<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        map.put(b,<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        System.out.println(JSON.toJSONString(map));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    输出结果：&#123;&#123;<span class=\"string\">&quot;hashKey&quot;</span>:<span class=\"string\">&quot;10086&quot;</span>,<span class=\"string\">&quot;id&quot;</span>:<span class=\"number\">1</span>&#125;:<span class=\"string\">&quot;1&quot;</span>,&#123;<span class=\"string\">&quot;hashKey&quot;</span>:<span class=\"string\">&quot;10086&quot;</span>,<span class=\"string\">&quot;id&quot;</span>:<span class=\"number\">1</span>&#125;:<span class=\"string\">&quot;1&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>所以，如果使用对象做键值对的键值的话，一定记得重写HashCode()方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> Objects.hash(id, hashKey);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">\t\t输出结果：&#123;&#123;<span class=\"string\">&quot;hashKey&quot;</span>:<span class=\"string\">&quot;10086&quot;</span>,<span class=\"string\">&quot;id&quot;</span>:<span class=\"number\">1</span>&#125;:<span class=\"string\">&quot;1&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>发生hash碰撞（不同的键值hash值相同）时的处理机制</p>\n<p>虽然在hash值的计算上都是在极力避免出现hash碰撞的情况，但是hash碰撞还是有可能会发生，那么当hash值相同但是键值不同的键值对该如何存放呢，分为两种情况：</p>\n<p>1、在当前的hash对应的bin下面会创建成一个长度不超过8的链表</p>\n<p>2、当链表长度大于等于8的时候，会转化红黑树，因为红黑树的查询效率是非常高的，但是占用空间会比链表大，典型的使用空间换时间，但是换的物超所值</p>\n</li>\n<li><p>单节点拉链法的实现过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> hash;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        Node&lt;K,V&gt; next;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t代码中的next就是下一个节点，当最后一个节点next为null时，代表着这个链表结束了。</p>\n<p>值得注意的是在JDK7之前链表使用的是头插法（不是使用的Node),当两个线程在执行resize()方法的时候可能会产生环形链表，在调用get()方法会死循环，导致OOM</p>\n</li>\n<li><p>链表转化为红黑树的方法过程</p>\n<p>​\t\t当链表的长度达到8时，已经是一个相对比较长的结构了，这时候查询的效率会随着链表的数量增长而降低，此时为了追求性能最大化，就会将链表转化为红黑树，这时候会产生一个问题：红黑树既然查询效率足够的高，为什么不直接采用红黑树的结构而使用链表达到8时才转变呢？</p>\n<p>这个其实也是有原因的，在一定的范围内，用空间换取时间效率是可取的，当链表长度比较短时，转变成红黑树，空间结构变大了，但是此时查询效率并没有因此而提高，反而得不偿失了，所以当链表达到阈值时来使用红黑树是相对比较划算的一种方案。</p>\n</li>\n</ul>\n<h5 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h5><p>   ​HashMap设计的最主要原因就是为了提高查询效率，get方法是使用的最频繁的一个方法之一，它主要就是靠hash算法获取的值来快速定位到索引，然后返回对应的索引对应值。</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Implements Map.get and related methods.</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return</span> the node, or null if none</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title function_\">getNode</span><span class=\"params\">(<span class=\"type\">int</span> hash, Object key)</span> &#123;</span><br><span class=\"line\">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"type\">int</span> n; K k;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((tab = table) != <span class=\"literal\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">          (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">              ((k = first.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">              <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">              <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                      ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                      <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>   ​\tget方法主要包含以下几个过程</p>\n<p>   ​\t1、获取key的hash计算参数</p>\n<p>   ​\t2、查找对应索引位置</p>\n<p>   ​\t3、如果是单节点Node直接返回Node,如果是链表Node在链表中获取Node节点，如果是红黑树节点，那么调用红黑树的查询方法快速找到Node并且返回</p>\n<h5 id=\"remove方法\"><a href=\"#remove方法\" class=\"headerlink\" title=\"remove方法\"></a>remove方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```java</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Implements Map.remove and related methods.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> matchValue if true only remove if value is equal</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> movable if false do not move other nodes while removing</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the node, or null if none</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title function_\">removeNode</span><span class=\"params\">(<span class=\"type\">int</span> hash, Object key, Object value,</span></span><br><span class=\"line\"><span class=\"params\">                               <span class=\"type\">boolean</span> matchValue, <span class=\"type\">boolean</span> movable)</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"type\">int</span> n, index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) != <span class=\"literal\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; node = <span class=\"literal\">null</span>, e; K k; V v;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                node = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                            ((k = e.key) == key ||</span><br><span class=\"line\">                             (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">                            node = e;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        p = e;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                                 (value != <span class=\"literal\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"built_in\">this</span>, tab, movable);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)</span><br><span class=\"line\">                    tab[index] = node.next;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    p.next = node.next;</span><br><span class=\"line\">                ++modCount;</span><br><span class=\"line\">                --size;</span><br><span class=\"line\">                afterNodeRemoval(node);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n\n\n\n<p>remove()方法也是个比较特殊的方法，它的作用和put()是完全相反的，基本也分为以下几个过程：</p>\n<p>1、如果是单节点Node，那么直接将对应的Node设置为Null</p>\n<p>2、如果是链表Node，那么将该Node删除的同时，将它前一个Node的next替换为后一个Node，保证链表的连续性</p>\n<p>3、如果是红黑树Node，那么就需要调用红黑树的删除节点方法进行删除了，此时如果红黑树的Node值为2-6个时，会调方法转化为链表结构的Node</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>HashMap是一个数组，但它是一个特殊的数组，包含了多种结构单元：单节点Node、Node链表、红黑树，根据实际情况互相转化，因为它的特殊性，造就了它超高的查询效率，<strong>O(1) 级别的查询效率</strong>，直接根据对应索引的位置找到对象并返回</p>\n<p>HashMap的容量也是有规律的，为了结构的稳定性以及保障索引的散列计算更加均匀，它的容量必须是<strong>2的幂次方</strong>，即使是没有传正确的容量参数，也是会进行校准的</p>\n<p>HashMap的扩容是达到一定阈值后会进行<strong>两倍放大</strong>，创建一个新的数组，将原来对象进行复制，并且会对单节点类型的元素重新计算他们的索引位置，如果是红黑树的话，会根据红黑树特有的方法进行扩容，在红黑树与链表之间进行动态转化</p>\n<p>HashMap和List、Set等集合一样，<strong>不是线程安全的</strong>，它在多线程情况是不具备线程安全特性的，如果同时有多个put或者多个remove会对它的数据造成比较大的影响，多线程环境下不推荐使用HashMap，它在多线程环境的替代是<strong>ConcurrentHashMap</strong>,关于ConcurrentHashMap有时间的还可以深入了解一下。</p>\n\n","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"}]}