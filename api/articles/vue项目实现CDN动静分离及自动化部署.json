{"title":"vue项目实现CDN动静分离及自动化部署","slug":"vue项目实现CDN动静分离及自动化部署","date":"2022-03-02T09:32:33.000Z","updated":"2022-06-02T01:05:59.616Z","comments":true,"path":"api/articles/vue项目实现CDN动静分离及自动化部署.json","excerpt":"前世今生1410是刚毕业那会做一个毕业照展示网站项目。早期使用的是Vue.js作为前端项目，Java作为后端项目。中间将Python写的服务端替换了Java后端。最后将Golang写的服务端替换了Python后端。近期又做了一些前端方面的改造：使用authelia作为Nginx层的SSO网关，设置为登录可访问（不能实现全站CDN的原因是需要NGINX层）照片使用腾讯云CDN访问，并且为加快访问速度还使用了腾讯云的万象图片处理抛弃后端接口，直接使用json存储照片列表实现前端项目动静分离，引入CDN加快访问速度使用coding的持续集成实现自动化部署以后再也不用操心改完代码还要做一堆的操作让代码上线了，网站访问速度和安全性都得到了提升。升级打怪过程这篇文章就主要介绍一下将vue项目build后实现动静分离和自动化部署过程，以及遇到的一些坑点。<br>以下是1410前端项目的项目结构：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>|-- public //存放不可变静态资源<br>\t\t|-- index.html<br>\t\t|-- favicon.ico<br>\t\t|-- data.json<br>|-- src<br>\t\t|-- plugins  //存放要引入的插件例如iview<br>\t\t|-- App.vue  //项目入口<br>\t\t|-- main.js  //项目配置<br>|-- config //存放打包成容器后的nginx的配置<br>    |-- nginx.conf<br>|-- .env.deploy 打包时指定的文件<br>|-- index.js 上传打包后dist文件夹到COS<br>|-- Dockerfile 打包成docker镜像的配置<br>|-- Jenkinsfile 持续集成的配置文件<br>|-- vue.config.js vue的配置文件<br>|-- package.json //存放打包命令以及依赖<br>...<br>改造vue项目实现动静分离如我上述的结构，改造vue项目非常简单，主要分为三步：在根目录中创建.env.deploy文件，然后写入1<br>2<br>NODE_ENV=production<br>DEPLOY=online<br>修改vue.config.js，将一下内容写入：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>// 根据自定义的变量来进行内容设置，将这块放在整个js文件的最上面即可<br>let BASE_URL = &#x27;/&#x27;<br>switch(process.env.DEPLOY) &#123;<br>    case &#x27;online&#x27;:<br>        BASE_URL = &#x27;https://cdn.songbo.fun/&#x27;<br>        break<br>    default:<br>        BASE_URL = &#x27;/&#x27;<br>&#125;<br>然后在module.exports中增加一行，注意&#x27;,&#x27;<br>publicPath: BASE_URL<br>在package.json中的scripts增加一行&quot;deploy&quot;: &quot;vue-cli-service build --mode deploy&quot; 此处注意**,**完成已上三步后就改造完成了，如果需要打包正常的项目使用npm run build 如果需要动静分离，使用npm run deploy 即可。<br>最终效果如下,在dist/index.html,对应的css地址就换成了如下的内容：1<br>&lt;link href=http://cdn.songbo.fun/static/css/app.887c93b2.css rel=preload as=style&gt;<br>** 注意 这一步也没有遇到什么坑点，很快就完成了项目的动静分离。实现自动化部署上一步已经实现了打包的过程，初步具备了前端站点动静分离的条件，最终生成的dist目录结构如下：1<br>2<br>3<br>4<br>5<br>|-- index.html   // 需要copy到docker镜像中<br>|-- static // 整个文件夹都需要放到COS上去，使用CDN访问<br>    |-- js<br>    |-- img<br>    |-- css<br>自动化部署总体流程比较简单，分为如下几步：选择一个devops服务提供商，我目前主要用两个：coding的持续集成以及github的action，配置起来都比较简单。选定Docker镜像并且准备好对应的配置，我这里选用的是nginx的docker镜像，准备了config/nginx.conf文件和Dockerfile文件，对应的文件存放位置可以在上文中看到，文件具体内容如下：<br>nginx.conf:1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br># nginx.conf<br>user nginx;<br>worker_processes 1;<br><br>error_log /var/log/nginx/error.log warn;<br>pid /var/run/nginx.pid;<br><br>events &#123;<br>  worker_connections 1024;<br>&#125;<br><br>http &#123;<br><br>  map $http_x_forwarded_for  $clientRealIp &#123;<br>      &quot;&quot;      $remote_addr;<br>      ~^(?P&lt;firstAddr&gt;[0-9\\.]+),?.*$  $firstAddr;<br>  &#125;<br><br>  include /etc/nginx/mime.types;<br>  default_type application/octet-stream;<br><br>  log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;<br>  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;<br>  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;<br><br>  access_log /var/log/nginx/access.log main;<br><br>  sendfile on;<br>  tcp_nopush on;<br><br>  gzip on;<br><br>  client_max_body_size 100m;<br>  client_body_buffer_size 10m;<br>  proxy_connect_timeout 600s;<br>  proxy_send_timeout 600s;<br>  proxy_read_timeout 600s;<br>  send_timeout 600s;<br><br>  proxy_request_buffering off;<br>  proxy_buffering off;<br><br>  server &#123;<br>    listen 80;<br>    server_name localhost;<br><br>    charset utf-8;<br><br>    root /usr/share/nginx/html;<br><br>    location / &#123;<br>      try_files $uri $uri/ /index.html;<br>    &#125;<br><br>    location ~* \\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ &#123;<br>      expires 1y;<br>      access_log off;<br>      add_header Cache-Control &quot;public&quot;;<br>    &#125;<br><br>    location ~* \\.(?:css|js)$ &#123;<br>      try_files $uri =404;<br>      expires 1y;<br>      access_log off;<br>      add_header Cache-Control &quot;public&quot;;<br>    &#125;<br><br>    location ~ ^.+\\..+$ &#123;<br>      try_files $uri =404;<br>    &#125;<br><br>    error_page 500 502 503 504 /50x.html;<br><br>    location = /50x.html &#123;<br>      root /usr/share/nginx/html;<br>    &#125;<br>  &#125;<br>&#125;<br>Dockerfile:1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>FROM nginx:1.17.9-alpine<br><br>ENV TZ=Asia/Shanghai<br><br>WORKDIR /usr/share/nginx/html<br><br>COPY ./config/nginx.conf /etc/nginx/nginx.conf<br><br>COPY ./dist /usr/share/nginx/html<br><br>EXPOSE 80<br>将对应的文件打包成镜像，然后部署到宿主机上，我使用的是coding的持续集成，对应的jenkinsfile如下：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>pipeline &#123;<br>  agent any<br>  stages &#123;<br>    stage(&#x27;检出&#x27;) &#123;<br>      steps &#123;<br>        checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: env.GIT_BUILD_REF]],<br>        userRemoteConfigs: [[url: env.GIT_REPO_URL, credentialsId: env.CREDENTIALS_ID]]])<br>      &#125;<br>    &#125;<br>    stage(&#x27;构建&#x27;) &#123;<br>      steps &#123;<br>        echo &#x27;构建中...&#x27;<br>        sh &#x27;npm install&#x27;<br>        sh &#x27;npm run deploy&#x27;<br>        sh &#x27;docker build -t $&#123;registry&#125;/$&#123;projectName&#125;:$&#123;GIT_COMMIT&#125;  .&#x27;<br>        sh &quot;docker login --username=&#x27;$&#123;username&#125;&#x27;  --password=&#x27;$&#123;password&#125;&#x27;  &#x27;$&#123;registry&#125;&#x27;&quot;<br>        sh &#x27;docker push $&#123;registry&#125;/$&#123;projectName&#125;:$&#123;GIT_COMMIT&#125;&#x27;<br>        echo &#x27;构建完成.&#x27;<br>      &#125;<br>    &#125;<br><br>    stage(&quot;部署到远端服务&quot;) &#123;<br>      steps &#123;<br>        script &#123;<br>          def remoteConfig = [:]<br>          remoteConfig.name = &quot;my-remote-server&quot;<br>          remoteConfig.host = &quot;10.0.0.1&quot;<br>          remoteConfig.port = 22<br>          remoteConfig.allowAnyHosts = true<br><br>          withCredentials([<br>            sshUserPrivateKey(<br>              credentialsId: &quot;$&#123;remote_cred&#125;&quot;,<br>              keyFileVariable: &#x27;id_rsa&#x27;<br>            ),<br>          ]) &#123;<br>            // SSH 登陆用户名<br>            remoteConfig.user = &quot;root&quot;<br>            // SSH 私钥文件地址<br>            remoteConfig.identityFile = id_rsa<br><br>            // 请确保远端环境中有 Docker 环境<br>            sshCommand(<br>              remote: remoteConfig,<br>              command: &quot;docker login -u $&#123;username&#125; -p $&#123;password&#125; $&#123;registry&#125;&quot;,<br>              sudo: true,<br>            )<br><br>            sshCommand(<br>              remote: remoteConfig,<br>              command: &quot;docker rm -f  $&#123;containerName&#125; | true&quot;,<br>              sudo: true,<br>            )<br><br>            // DOCKER_IMAGE_VERSION 中涉及到 GIT_LOCAL_BRANCH / GIT_TAG / GIT_COMMIT 的环境变量的使用<br>            // 需要在本地完成拼接后，再传入到远端服务器中使用<br>            DOCKER_IMAGE_URL = sh(<br>              script: &quot;echo $&#123;registry&#125;/$&#123;projectName&#125;:$&#123;GIT_COMMIT&#125;&quot;,<br>              returnStdout: true<br>            )<br><br>            sshCommand(<br>              remote: remoteConfig,<br>              command: &quot;docker run -d -p 2111:80 --name $&#123;containerName&#125; $&#123;DOCKER_IMAGE_URL&#125;&quot;,<br>              sudo: true,<br>            )<br><br>            echo &quot;部署成功，请到 https://1410.xxxx.com 预览效果&quot;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    stage(&#x27;上传CDN&#x27;) &#123;<br>      steps &#123;<br>        echo &#x27;构建中...&#x27;<br>        sh &#x27;node index.js&#x27;<br>        echo &#x27;上传完成&#x27;<br>      &#125;<br>    &#125;<br><br>  &#125;<br>  environment &#123;<br>    registry = &#x27;&#x27;<br>    username = &#x27;&#x27;<br>    password = &#x27;&#x27;<br>    projectName = &#x27;1410&#x27;<br>    containerName = &#x27;1410&#x27;<br>    remote_cred = &#x27;&#x27;<br>  &#125;<br>&#125;<br>为防止docker镜像启动不成功，导致原有的网站不可访问，所以将对应的dist中的文件上传到CDN中作为最后一步，这样可以保证服务启动后，访问的是最新的站点，将dist文件上传到cos上我使用的是我前期写的一个开源项目alidaodao-cos-uploader,具体的步骤可以访问项目后进行配置。到此整个自动化部署的过程也结束了，可以看看对应的运行步骤截图：<br> [Figure] ","covers":["https://imagecdn.bosong.online/pic/KtliwD.png"],"content":"<div class=\"story post-story\"><h2 id=\"前世今生\"><a href=\"#前世今生\" class=\"headerlink\" title=\"前世今生\"></a>前世今生</h2><p>1410是刚毕业那会做一个毕业照展示网站项目。</p>\n<p>早期使用的是Vue.js作为前端项目，Java作为后端项目。</p>\n<p>中间将Python写的服务端替换了Java后端。</p>\n<p>最后将Golang写的服务端替换了Python后端。</p>\n<p>近期又做了一些前端方面的改造：</p>\n<ul>\n<li>使用authelia作为Nginx层的SSO网关，设置为登录可访问（不能实现全站CDN的原因是需要NGINX层）</li>\n<li>照片使用腾讯云CDN访问，并且为加快访问速度还使用了腾讯云的万象图片处理</li>\n<li>抛弃后端接口，直接使用json存储照片列表</li>\n<li>实现前端项目动静分离，引入CDN加快访问速度</li>\n<li>使用coding的持续集成实现自动化部署</li>\n</ul>\n<p>以后再也不用操心改完代码还要做一堆的操作让代码上线了，网站访问速度和安全性都得到了提升。</p>\n</div><div class=\"story post-story\"><h2 id=\"升级打怪过程\"><a href=\"#升级打怪过程\" class=\"headerlink\" title=\"升级打怪过程\"></a>升级打怪过程</h2><p>这篇文章就主要介绍一下将vue项目build后实现动静分离和自动化部署过程，以及遇到的一些坑点。<br>以下是1410前端项目的项目结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- public //存放不可变静态资源</span><br><span class=\"line\">\t\t|-- index.html</span><br><span class=\"line\">\t\t|-- favicon.ico</span><br><span class=\"line\">\t\t|-- data.json</span><br><span class=\"line\">|-- src</span><br><span class=\"line\">\t\t|-- plugins  //存放要引入的插件例如iview</span><br><span class=\"line\">\t\t|-- App.vue  //项目入口</span><br><span class=\"line\">\t\t|-- main.js  //项目配置</span><br><span class=\"line\">|-- config //存放打包成容器后的nginx的配置</span><br><span class=\"line\">    |-- nginx.conf</span><br><span class=\"line\">|-- .env.deploy 打包时指定的文件</span><br><span class=\"line\">|-- index.js 上传打包后dist文件夹到COS</span><br><span class=\"line\">|-- Dockerfile 打包成docker镜像的配置</span><br><span class=\"line\">|-- Jenkinsfile 持续集成的配置文件</span><br><span class=\"line\">|-- vue.config.js vue的配置文件</span><br><span class=\"line\">|-- package.json //存放打包命令以及依赖</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"改造vue项目实现动静分离\"><a href=\"#改造vue项目实现动静分离\" class=\"headerlink\" title=\"改造vue项目实现动静分离\"></a>改造vue项目实现动静分离</h3><p>如我上述的结构，改造vue项目非常简单，主要分为三步：</p>\n<ol>\n<li><p>在根目录中创建<code>.env.deploy</code>文件，然后写入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NODE_ENV=production</span><br><span class=\"line\">DEPLOY=online</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改<code>vue.config.js</code>，将一下内容写入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根据自定义的变量来进行内容设置，将这块放在整个js文件的最上面即可</span><br><span class=\"line\">let BASE_URL = &#x27;/&#x27;</span><br><span class=\"line\">switch(process.env.DEPLOY) &#123;</span><br><span class=\"line\">    case &#x27;online&#x27;:</span><br><span class=\"line\">        BASE_URL = &#x27;https://cdn.songbo.fun/&#x27;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    default:</span><br><span class=\"line\">        BASE_URL = &#x27;/&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">然后在module.exports中增加一行，注意&#x27;,&#x27;</span><br><span class=\"line\">publicPath: BASE_URL</span><br></pre></td></tr></table></figure></li>\n<li><p>在<code>package.json</code>中的<strong>scripts</strong>增加一行<code>&quot;deploy&quot;: &quot;vue-cli-service build --mode deploy&quot;</code> 此处注意**,**</p>\n</li>\n</ol>\n<p>完成已上三步后就改造完成了，如果需要打包正常的项目使用<code>npm run build</code> 如果需要动静分离，使用<code>npm run deploy</code> 即可。<br>最终效果如下,在<code>dist/index.html</code>,对应的css地址就换成了如下的内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link href=http://cdn.songbo.fun/static/css/app.887c93b2.css rel=preload as=style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>** 注意 这一步也没有遇到什么坑点，很快就完成了项目的动静分离。</p>\n<h3 id=\"实现自动化部署\"><a href=\"#实现自动化部署\" class=\"headerlink\" title=\"实现自动化部署\"></a>实现自动化部署</h3><p>上一步已经实现了打包的过程，初步具备了前端站点动静分离的条件，最终生成的dist目录结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- index.html   // 需要copy到docker镜像中</span><br><span class=\"line\">|-- static // 整个文件夹都需要放到COS上去，使用CDN访问</span><br><span class=\"line\">    |-- js</span><br><span class=\"line\">    |-- img</span><br><span class=\"line\">    |-- css</span><br></pre></td></tr></table></figure>\n\n<p>自动化部署总体流程比较简单，分为如下几步：</p>\n<ol>\n<li>选择一个devops服务提供商，我目前主要用两个：coding的持续集成以及github的action，配置起来都比较简单。</li>\n<li>选定Docker镜像并且准备好对应的配置，我这里选用的是<code>nginx</code>的docker镜像，准备了<code>config/nginx.conf</code>文件和<code>Dockerfile</code>文件，对应的文件存放位置可以在上文中看到，文件具体内容如下：<br>nginx.conf:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># nginx.conf</span><br><span class=\"line\">user nginx;</span><br><span class=\"line\">worker_processes 1;</span><br><span class=\"line\"></span><br><span class=\"line\">error_log /var/log/nginx/error.log warn;</span><br><span class=\"line\">pid /var/run/nginx.pid;</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">  worker_connections 1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  map $http_x_forwarded_for  $clientRealIp &#123;</span><br><span class=\"line\">      &quot;&quot;      $remote_addr;</span><br><span class=\"line\">      ~^(?P&lt;firstAddr&gt;[0-9\\.]+),?.*$  $firstAddr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  include /etc/nginx/mime.types;</span><br><span class=\"line\">  default_type application/octet-stream;</span><br><span class=\"line\"></span><br><span class=\"line\">  log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">  access_log /var/log/nginx/access.log main;</span><br><span class=\"line\"></span><br><span class=\"line\">  sendfile on;</span><br><span class=\"line\">  tcp_nopush on;</span><br><span class=\"line\"></span><br><span class=\"line\">  gzip on;</span><br><span class=\"line\"></span><br><span class=\"line\">  client_max_body_size 100m;</span><br><span class=\"line\">  client_body_buffer_size 10m;</span><br><span class=\"line\">  proxy_connect_timeout 600s;</span><br><span class=\"line\">  proxy_send_timeout 600s;</span><br><span class=\"line\">  proxy_read_timeout 600s;</span><br><span class=\"line\">  send_timeout 600s;</span><br><span class=\"line\"></span><br><span class=\"line\">  proxy_request_buffering off;</span><br><span class=\"line\">  proxy_buffering off;</span><br><span class=\"line\"></span><br><span class=\"line\">  server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">    charset utf-8;</span><br><span class=\"line\"></span><br><span class=\"line\">    root /usr/share/nginx/html;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">      try_files $uri $uri/ /index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~* \\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ &#123;</span><br><span class=\"line\">      expires 1y;</span><br><span class=\"line\">      access_log off;</span><br><span class=\"line\">      add_header Cache-Control &quot;public&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~* \\.(?:css|js)$ &#123;</span><br><span class=\"line\">      try_files $uri =404;</span><br><span class=\"line\">      expires 1y;</span><br><span class=\"line\">      access_log off;</span><br><span class=\"line\">      add_header Cache-Control &quot;public&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~ ^.+\\..+$ &#123;</span><br><span class=\"line\">      try_files $uri =404;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\"></span><br><span class=\"line\">    location = /50x.html &#123;</span><br><span class=\"line\">      root /usr/share/nginx/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nDockerfile:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nginx:1.17.9-alpine</span><br><span class=\"line\"></span><br><span class=\"line\">ENV TZ=Asia/Shanghai</span><br><span class=\"line\"></span><br><span class=\"line\">WORKDIR /usr/share/nginx/html</span><br><span class=\"line\"></span><br><span class=\"line\">COPY ./config/nginx.conf /etc/nginx/nginx.conf</span><br><span class=\"line\"></span><br><span class=\"line\">COPY ./dist /usr/share/nginx/html</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 80</span><br></pre></td></tr></table></figure></li>\n<li>将对应的文件打包成镜像，然后部署到宿主机上，我使用的是coding的持续集成，对应的jenkinsfile如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline &#123;</span><br><span class=\"line\">  agent any</span><br><span class=\"line\">  stages &#123;</span><br><span class=\"line\">    stage(&#x27;检出&#x27;) &#123;</span><br><span class=\"line\">      steps &#123;</span><br><span class=\"line\">        checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: env.GIT_BUILD_REF]],</span><br><span class=\"line\">        userRemoteConfigs: [[url: env.GIT_REPO_URL, credentialsId: env.CREDENTIALS_ID]]])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stage(&#x27;构建&#x27;) &#123;</span><br><span class=\"line\">      steps &#123;</span><br><span class=\"line\">        echo &#x27;构建中...&#x27;</span><br><span class=\"line\">        sh &#x27;npm install&#x27;</span><br><span class=\"line\">        sh &#x27;npm run deploy&#x27;</span><br><span class=\"line\">        sh &#x27;docker build -t $&#123;registry&#125;/$&#123;projectName&#125;:$&#123;GIT_COMMIT&#125;  .&#x27;</span><br><span class=\"line\">        sh &quot;docker login --username=&#x27;$&#123;username&#125;&#x27;  --password=&#x27;$&#123;password&#125;&#x27;  &#x27;$&#123;registry&#125;&#x27;&quot;</span><br><span class=\"line\">        sh &#x27;docker push $&#123;registry&#125;/$&#123;projectName&#125;:$&#123;GIT_COMMIT&#125;&#x27;</span><br><span class=\"line\">        echo &#x27;构建完成.&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    stage(&quot;部署到远端服务&quot;) &#123;</span><br><span class=\"line\">      steps &#123;</span><br><span class=\"line\">        script &#123;</span><br><span class=\"line\">          def remoteConfig = [:]</span><br><span class=\"line\">          remoteConfig.name = &quot;my-remote-server&quot;</span><br><span class=\"line\">          remoteConfig.host = &quot;10.0.0.1&quot;</span><br><span class=\"line\">          remoteConfig.port = 22</span><br><span class=\"line\">          remoteConfig.allowAnyHosts = true</span><br><span class=\"line\"></span><br><span class=\"line\">          withCredentials([</span><br><span class=\"line\">            sshUserPrivateKey(</span><br><span class=\"line\">              credentialsId: &quot;$&#123;remote_cred&#125;&quot;,</span><br><span class=\"line\">              keyFileVariable: &#x27;id_rsa&#x27;</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ]) &#123;</span><br><span class=\"line\">            // SSH 登陆用户名</span><br><span class=\"line\">            remoteConfig.user = &quot;root&quot;</span><br><span class=\"line\">            // SSH 私钥文件地址</span><br><span class=\"line\">            remoteConfig.identityFile = id_rsa</span><br><span class=\"line\"></span><br><span class=\"line\">            // 请确保远端环境中有 Docker 环境</span><br><span class=\"line\">            sshCommand(</span><br><span class=\"line\">              remote: remoteConfig,</span><br><span class=\"line\">              command: &quot;docker login -u $&#123;username&#125; -p $&#123;password&#125; $&#123;registry&#125;&quot;,</span><br><span class=\"line\">              sudo: true,</span><br><span class=\"line\">            )</span><br><span class=\"line\"></span><br><span class=\"line\">            sshCommand(</span><br><span class=\"line\">              remote: remoteConfig,</span><br><span class=\"line\">              command: &quot;docker rm -f  $&#123;containerName&#125; | true&quot;,</span><br><span class=\"line\">              sudo: true,</span><br><span class=\"line\">            )</span><br><span class=\"line\"></span><br><span class=\"line\">            // DOCKER_IMAGE_VERSION 中涉及到 GIT_LOCAL_BRANCH / GIT_TAG / GIT_COMMIT 的环境变量的使用</span><br><span class=\"line\">            // 需要在本地完成拼接后，再传入到远端服务器中使用</span><br><span class=\"line\">            DOCKER_IMAGE_URL = sh(</span><br><span class=\"line\">              script: &quot;echo $&#123;registry&#125;/$&#123;projectName&#125;:$&#123;GIT_COMMIT&#125;&quot;,</span><br><span class=\"line\">              returnStdout: true</span><br><span class=\"line\">            )</span><br><span class=\"line\"></span><br><span class=\"line\">            sshCommand(</span><br><span class=\"line\">              remote: remoteConfig,</span><br><span class=\"line\">              command: &quot;docker run -d -p 2111:80 --name $&#123;containerName&#125; $&#123;DOCKER_IMAGE_URL&#125;&quot;,</span><br><span class=\"line\">              sudo: true,</span><br><span class=\"line\">            )</span><br><span class=\"line\"></span><br><span class=\"line\">            echo &quot;部署成功，请到 https://1410.xxxx.com 预览效果&quot;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stage(&#x27;上传CDN&#x27;) &#123;</span><br><span class=\"line\">      steps &#123;</span><br><span class=\"line\">        echo &#x27;构建中...&#x27;</span><br><span class=\"line\">        sh &#x27;node index.js&#x27;</span><br><span class=\"line\">        echo &#x27;上传完成&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  environment &#123;</span><br><span class=\"line\">    registry = &#x27;&#x27;</span><br><span class=\"line\">    username = &#x27;&#x27;</span><br><span class=\"line\">    password = &#x27;&#x27;</span><br><span class=\"line\">    projectName = &#x27;1410&#x27;</span><br><span class=\"line\">    containerName = &#x27;1410&#x27;</span><br><span class=\"line\">    remote_cred = &#x27;&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>为防止docker镜像启动不成功，导致原有的网站不可访问，所以将对应的<code>dist</code>中的文件上传到CDN中作为最后一步，这样可以保证服务启动后，访问的是最新的站点，将dist文件上传到cos上我使用的是我前期写的一个开源项目<a href=\"https://github.com/dislazy/alidaodao-cos-uploader\">alidaodao-cos-uploader</a>,具体的步骤可以访问项目后进行配置。</li>\n</ol>\n<p>到此整个自动化部署的过程也结束了，可以看看对应的运行步骤截图：<br><img src=\"https://imagecdn.bosong.online/pic/KtliwD.png\" class=\"lazyload\" data-srcset=\"https://imagecdn.bosong.online/pic/KtliwD.png\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" alt=\"coding持续集成\"></p>\n</div><div class=\"story post-story\"><h2 id=\"遇到的问题以及解决方案\"><a href=\"#遇到的问题以及解决方案\" class=\"headerlink\" title=\"遇到的问题以及解决方案\"></a>遇到的问题以及解决方案</h2><h3 id=\"coding持续集成部署到宿主机时始终报错：invalid-privatekey-B-51d78dde\"><a href=\"#coding持续集成部署到宿主机时始终报错：invalid-privatekey-B-51d78dde\" class=\"headerlink\" title=\"coding持续集成部署到宿主机时始终报错：invalid privatekey: [B@51d78dde\"></a>coding持续集成部署到宿主机时始终报错：<strong>invalid privatekey: [B@51d78dde</strong></h3><p>最终查到该问题是由于我使用的连接到宿主机的SSH密钥的版本过新导致的，我使用的密钥如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----BEGIN OPENSSH PRIVATE KEY-----</span><br><span class=\"line\"></span><br><span class=\"line\">PRIVATE KEY</span><br><span class=\"line\"></span><br><span class=\"line\">-----END OPENSSH PRIVATE KEY-----</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但是coding使用的Jenkins只支持如下密钥：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----BEGIN RSA PRIVATE KEY-----</span><br><span class=\"line\"></span><br><span class=\"line\">PRIVATE KEY</span><br><span class=\"line\"></span><br><span class=\"line\">-----END RSA PRIVATE KEY-----</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>问题找到，解决就简单了，将对应的OPENSSH的密钥改成RSA的密钥即可：<code>ssh-keygen -p -m PEM -f 你的密钥地址</code>,然后再转化的密钥存入对应凭据中就解决了。</p>\n</div><div class=\"story post-story\"><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>对于服务端开发者，自动化早已深入人心，它能帮你节省大量的时间和精力，如何用好自动化技术也是我们的挑战,欢迎与我一起交流。</p>\n<p>参考文献：</p>\n<ul>\n<li><a href=\"https://help.coding.net/docs/ci/practice/deploy/ssh.html\">持续集成 &#x2F; 自动部署 &#x2F; Linux 服务器</a></li>\n</ul>\n\n</div>","more":"<div class=\"story post-story\"><h2 id=\"遇到的问题以及解决方案\"><a href=\"#遇到的问题以及解决方案\" class=\"headerlink\" title=\"遇到的问题以及解决方案\"></a>遇到的问题以及解决方案</h2><h3 id=\"coding持续集成部署到宿主机时始终报错：invalid-privatekey-B-51d78dde\"><a href=\"#coding持续集成部署到宿主机时始终报错：invalid-privatekey-B-51d78dde\" class=\"headerlink\" title=\"coding持续集成部署到宿主机时始终报错：invalid privatekey: [B@51d78dde\"></a>coding持续集成部署到宿主机时始终报错：<strong>invalid privatekey: [B@51d78dde</strong></h3><p>最终查到该问题是由于我使用的连接到宿主机的SSH密钥的版本过新导致的，我使用的密钥如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----BEGIN OPENSSH PRIVATE KEY-----</span><br><span class=\"line\"></span><br><span class=\"line\">PRIVATE KEY</span><br><span class=\"line\"></span><br><span class=\"line\">-----END OPENSSH PRIVATE KEY-----</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但是coding使用的Jenkins只支持如下密钥：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----BEGIN RSA PRIVATE KEY-----</span><br><span class=\"line\"></span><br><span class=\"line\">PRIVATE KEY</span><br><span class=\"line\"></span><br><span class=\"line\">-----END RSA PRIVATE KEY-----</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>问题找到，解决就简单了，将对应的OPENSSH的密钥改成RSA的密钥即可：<code>ssh-keygen -p -m PEM -f 你的密钥地址</code>,然后再转化的密钥存入对应凭据中就解决了。</p>\n</div><div class=\"story post-story\"><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>对于服务端开发者，自动化早已深入人心，它能帮你节省大量的时间和精力，如何用好自动化技术也是我们的挑战,欢迎与我一起交流。</p>\n<p>参考文献：</p>\n<ul>\n<li><a href=\"https://help.coding.net/docs/ci/practice/deploy/ssh.html\">持续集成 &#x2F; 自动部署 &#x2F; Linux 服务器</a></li>\n</ul>\n\n</div>","categories":[{"name":"技术手册","path":"api/categories/技术手册.json"}],"tags":[{"name":"nginx","path":"api/tags/nginx.json"},{"name":"docker","path":"api/tags/docker.json"},{"name":"CDN","path":"api/tags/CDN.json"},{"name":"DEVOPS","path":"api/tags/DEVOPS.json"}]}